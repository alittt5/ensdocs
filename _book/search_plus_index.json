{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction The Ethereum Name Service (ENS) is a distributed, open, and extensible naming system based on the Ethereum blockchain. ENS’s job is to map human-readable names like ‘alice.eth’ to machine-readable identifiers such as Ethereum addresses, other cryptocurrency addresses, content hashes, and metadata. ENS also supports ‘reverse resolution’, making it possible to associate metadata such as canonical names or interface descriptions with Ethereum addresses. ENS has similar goals to DNS, the Internet’s Domain Name Service, but has significantly different architecture due to the capabilities and constraints provided by the Ethereum blockchain. Like DNS, ENS operates on a system of dot-separated hierarchical names called domains, with the owner of a domain having full control over subdomains. Top-level domains, like ‘.eth’ and ‘.test’, are owned by smart contracts called registrars, which specify rules governing the allocation of their subdomains. Anyone may, by following the rules imposed by these registrar contracts, obtain ownership of a domain for their own use. ENS also supports importing in DNS names already owned by the user for use on ENS. Because of the hierarchal nature of ENS, anyone who owns a domain at any level may configure subdomains - for themselves or others - as desired. For instance, if Alice owns 'alice.eth', she can create 'pay.alice.eth' and configure it as she wishes. ENS is deployed on the Ethereum main network and on several test networks. If you use a library such as the ensjs Javascript library, or an end-user application, it will automatically detect the network you are interacting with and use the ENS deployment on that network. You can try ENS out for yourself now by using the ENS Manager App, or by using any of the many ENS enabled applications on our homepage. ENS Architecture ENS has two principal components: the registry, and resolvers. .png>) The ENS registry consists of a single smart contract that maintains a list of all domains and subdomains, and stores three critical pieces of information about each: The owner of the domain The resolver for the domain The caching time-to-live for all records under the domain The owner of a domain may be either an external account (a user) or a smart contract. A registrar is simply a smart contract that owns a domain and issues subdomains of that domain to users that follow some set of rules defined in the contract. Owners of domains in the ENS registry may: Set the resolver and TTL for the domain Transfer ownership of the domain to another address Change the ownership of subdomains The ENS registry is deliberately straightforward and exists only to map from a name to the resolver responsible for it. Resolvers are responsible for the actual process of translating names into addresses. Any contract that implements the relevant standards may act as a resolver in ENS. General-purpose resolver implementations are offered for users whose requirements are straightforward, such as serving an infrequently changed address for a name. Each record type - cryptocurrency address, IPFS content hash, and so forth - defines a method or methods that a resolver must implement in order to provide records of that kind. New record types may be defined at any time via the EIP standardization process, with no need to make changes to the ENS registry or to existing resolvers in order to support them. Resolving a name in ENS is a two-step process: First, ask the registry what resolver is responsible for the name, and second, ask that resolver for the answer to your query. In the above example, we're trying to find the Ethereum address pointed to by 'foo.eth'. First, we ask the registry which resolver is responsible for 'foo.eth'. Then, we query that resolver for the address of 'foo.eth'. Namehash Resource constraints in smart contracts make interacting directly with human-readable names inefficient, so ENS works purely with fixed length 256-bit cryptographic hashes. In order to derive the hash from a name while still preserving its hierarchal properties, a process called Namehash is used. For example, the namehash of 'alice.eth' is 0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec; this is the representation of names that is used exclusively inside ENS. Namehash is a recursive process that can generate a unique hash for any valid domain name. Starting with the namehash of any domain - for example, 'alice.eth' - it's possible to derive the namehash of any subdomain - for example 'iam.alice.eth' - without having to know or handle the original human-readable name. It is this property that makes it possible for ENS to provide a hierarchal system, without having to deal with human-readable text strings internally. Before being hashed with namehash, names are first normalized, using a process called UTS-46 normalization. This ensures that upper- and lower-case names are treated equivalently, and that invalid characters are prohibited. Anything that hashes and resolves a name must first normalize it, to ensure that all users get a consistent view of ENS. For details on how namehash and normalization works, see the developer documentation on name processing. Getting Started ENS has documentation for a variety of audiences, including dapp developers and contract developers, as well as reference documentation. I'm a dapp developer and want to add ENS support to my dapp Check out the dapp developer guide, starting with ENS Enabling your Dapp. You'll want to choose one of the many available ENS Libraries to get started working with ENS. I'm a contract developer and want to interact with ENS from my contract code Check out the Contract Developer Guide, starting with Resolving Names On-chain. You can also write your own resolver (to customise the process of looking up names), or your own registrar (to customise the process of registering new names). I want reference documentation for the ENS smart contracts Check out the Contract API Reference. We have reference documentation for ENS's core contract, the registry, for resolvers, and for commonly-used registrars such as the Test registrar, reverse registrar, and the .eth registrar. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"terminology.html":{"url":"terminology.html","title":"Terminology","keywords":"","body":"Terminology Controller: The account that may edit the records of a name. The Controller may be changed by the Registrant or Controller. Label: An individual component of a name, such as 'alice'. Labelhash: The keccak256 hash of an individual label. Name: An ENS identifier such as 'alice.eth'. Names may consist of multiple parts, called labels, separated by dots. Namehash: The algorithm used to process an ENS name and return a cryptographic hash uniquely identifying that name. Namehash takes a name as input and produces a node. Node: A cryptographic hash uniquely identifying a name. Owner: The owner of a name is the entity referenced in the ENS registry's owner field. An owner may transfer ownership, set a resolver or TTL, and create or reassign subdomains. Registrar: A registrar is a contract responsible for allocating subdomains. Registrars can be configured at any level of ENS, and are pointed to by the owner field of the registry. Registration: A registration is a registrar's record of a user's ownership of a name. This is distinct from the owner field in the Registry; registrations are maintained in the registrar contract and additionally store information on expiry date, fees paid, etc. Registrant: The owner of a registration. The registrant may transfer the registration, set the Controller, and reclaim ownership of the name in the registry if required. Registry: The core contract of ENS, the registry maintains a mapping from domain name (at any level - x, y.x, z.y.x etc) to owner, resolver, and time-to-live. Resolver: A resolver is a contract that maps from name to the resource (e.g., cryptocurrency addresses, content hash, etc). Resolvers are pointed to by the resolver field of the registry. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"frequently-asked-questions.html":{"url":"frequently-asked-questions.html","title":"Frequently Asked Questions","keywords":"","body":"Frequently Asked Questions About the ENS Registry Why are names registered as hashes? Hashes provide a fixed length identifier that can easily be passed around between contracts with fixed overhead and no issues passing around variable-length strings. Which wallets and dapps support ENS so far? A partial list can be seen on our homepage. Once I own a name, can I create my own subdomains? Yes. You can create whatever subdomains you wish and assign ownership of them to other people if you desire. You can even set up your own registrar for your domain. Can I change the address my name points to after I’ve bought it? Yes, you can update the addresses and other resources pointed to by your name at any time. Can I register a TLD of my own in the ENS? No. We consider ENS to be part of the 'global namespace' inhabited by DNS, and so we do our best not to pollute that namespace. ENS-specific TLDs are restricted to only .eth (on mainnet), or .eth and .test (on Ropsten), plus any special purpose TLDs such as those required to permit reverse lookups. In addition to that, we are deploying support for importing DNS domains from the majority of DNS top-level domains using an integration that relies on DNSSEC. For details on those plans, please read this post. Who owns the ENS rootnode? What powers does that grant them? The root node is presently owned by a multisig contract, with keys held by trustworthy individuals in the Ethereum community. We expect that this will be hands-off, with the root ownership only used to effect administrative changes, such as the introduction of a new TLD, or to recover from an emergency such as a critical vulnerability in a TLD registrar. The keyholders are drawn from respected members of the community, and with the exception of Nick Johnson, founder of ENS, are unaffiliated with ENS. We ask and expect them to exercise their individual judgement acting in the interests of the ENS community, rather than rubber-stamping requests made to them by ENS developers. Since the owner of a node can change ownership of a subnode (unless they have otherwise locked it from their control), the owner of the root can change any node in the ENS tree. This means that the keyholders can replace the contracts that govern issuing and managing domains, giving them ultimate control over the structure of the ENS system and the names registered in it. However, the root key holders have locked control of the .eth registrar contract, which means that even keyholders cannot affect the ownership of .eth domains. The keyholders are still capable of doing the followings: Control allocation and replacement of TLDs other than .eth - this is required to implement DNSSEC integration. Enable and disable controllers for the .eth registrar, which affect registration and renewal policies for .eth names. Update the pricing for .eth names. Receive and manage registration revenue. Over time, we plan to reduce and decentralise human control over the system. Powers still held by the ENS root, such as those to set pricing and renewal conditions for domains, will be decentralised as robust systems become available to permit doing so. What about foreign characters? What about upper case letters? Is any unicode character valid? Since the ENS contracts only deal with hashes, they have no direct way to enforce limits on what can be registered; character length restrictions are implemented by allowing users to challenge a short name by providing its preimage to prove it’s too short. This means that you can in theory register both ‘foo.eth’ and ‘FOO.eth’, or even \\.eth. However, resolvers such as browsers and wallets should apply the nameprep algorithm to any names users enter before resolving; as a result, names that are not valid outputs of nameprep will not be resolvable by standard resolvers, making them effectively useless. Dapps that assist users with registering names should prevent users from registering unresolvable names by using nameprep to preprocess names being requested for registration. Nameprep isn’t enforced in the ENS system. Is this a security/spoofing/phishing concern? It’s not enforced by the ENS contracts, but, as described above, resolvers are expected to use it before resolving names. This means that non-nameprep names will not be resolvable. What are the differences between ENS and other naming services such as Namecoin and Handshake? ENS complements and extends the usefulness of DNS with decentralised, trustworthy name resolution for web3 resources such as blockchain addresses and distributed content, while Namecoin and Handshake are efforts to replace all or part of DNS with a blockchain-based alternative. About the .eth Permanent Registrar How do the ENS Manager App and the Twitter bot know what names people are buying? The ENS Manager App and the Twitter bot have built-in lists of common names, drawn from an English dictionary and Alexa’s list of top 1 million Internet domain names. They use these lists to show you when common names are bought or renewed. We do this because if the app didn’t reveal these names, anyone with a little technical skill could find them out anyway, giving them an advantage over those who don’t have the capacity to build their own list and code to check names against it. What does it cost to register a .eth domain? Currently, registration costs are set at the following prices: 5+ character .eth names: $5 in ETH per year. 4 character .eth names: $160 in ETH per year. 3 character .eth names $640 in ETH per year. 3 and 4 character names have higher pricing to reflect the small number of these names available. What happens if I forget to extend the registration of a name? After your name expires, there is a 90 day grace period in which the owner can't edit the records but can still re-register the name. After the grace period, the name is released for registration by anyone with a temporary premium which decreases over a 28 days period. The released name continues to resolve your ETH address until the new owner overwrites it. What kinds of behaviours are likely to result in losing ownership of a name? The .eth registrar is structured such that names, once issued, cannot be revoked so long as an active registration is maintained. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-deployments.html":{"url":"ens-deployments.html","title":"ENS Deployments","keywords":"","body":"ENS Deployments If you are working with an ENS library, your library will automatically find the ENS deployment you need. If for whatever reason, you need to interact with ENS directly, details for the currently supported deployments are detailed here. The ENS registry is deployed at 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e. This same address is used across Mainnet, Ropsten, Rinkeby and Goerli. On mainnet, the following registrars are deployed: .eth, using the .eth Permanent registrar. .xyz, via DNS integration .luxe, via a custom integration that allows any owner of a .luxe DNS name to use ENS. .kred, via a custom integration that synchs and changes to a .kred ENS token to DNS automatically. .art, via a custom integration To find out the contract address of each tld, check the \"controller\" address of the tld (eg: https://app.ens.domains/name/xyz for .xyz Ropsten test network has the .test registrar deployed. This registrar permits anyone to instantly register a domain for testing purposes; these domains persist for 28 days. In addition, the test networks also have a deployment of the .eth registrar for testing purposes. For other contract addresses such as root, multisig, controller, public resolver, and so on, you can see their address under https://app.ens.domains/name/ens.eth/subdomains Back in February 2020, the ENS registry was migrated to the new contract address to patch security vulnerabilities (Read more detail here). The prior registry addresses were: Mainnet, at 0x314159265dd8dbb310642f98f50c066173c1259b. Ropsten, at 0x112234455c3a32fd11230c42e7bccd4a84e02010. Rinkeby, at 0xe7410170f87102df0055eb195163a03b7f2bff4a. Goerli, at 0x112234455c3a32fd11230c42e7bccd4a84e02010. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"permanent-registrar-faq.html":{"url":"permanent-registrar-faq.html","title":"Registrar Frequently Asked Questions","keywords":"","body":"Registrar Frequently Asked Questions About the ENS Registrar How many transactions are required to register a .eth name? The registrar uses two transactions (commit and reveal) to register a name. How long does it take to register a name using the .eth registrar? It takes less than 5 minutes to register a name, including a 1-minute delay between the first and second transactions to prevent frontrunning. Do we need to do anything to ensure the continued use of existing ENS names? Make sure you renew your ENS names before they expire! You add registration years to any name at any time, and for any duration you'd like. What happens if I have several ENS names with different renewal dates? You can add registration years to many names at a time on your My Account page in the ENS Manager App. How do renewals work? Anyone can add registration years to any existing name by paying the required fee, at any time. There is no maximum limitation of the renewal duration but there is a minimum renewal period of 28 days. Can someone grab my domains at the end of my subscription period? You can renew your name at any time during the period you own it. Making sure you renew before the name expires will prevent someone else from registering the name. There is also a 'grace period' of 90 days after your name expires. You can renew the name to retain ownership of it during the grace period. How much will the yearly renewals cost? Yearly renewals cost $5/year for names that are 5 characters or longer. 4 character names cost $160/year, and 3 character names cost $640/year. Fees are paid in ETH. The ETH/USD exchange rate is set by the Chainlink ETH/USD oracle. What happens to the renewal fees? Do I get them back? Rather than being locked and held, as in the original interim registrar, renewal fees in the permanent registrar are spent. You will not get them back. How will ENS team manage and spend the funds? Will there be a foundation or transparent oversight? Funds are sent to the ENS root multisig, for the keyholders to determine how funds get allocated. We're considering multiple options for the long-term use of the funds, such as funding the core ENS team, as well as other teams building on ENS. There are also tax considerations to address. How are funds from .eth registration income used? It's ultimately up to the keyholders to allocate the funds. We hope they will fund ENS ecosystems projects. If available funds exceed the reasonable needs of the ENS ecosystem, we hope other Ethereum projects will receive them. Where can I manage all my ENS names? Simply go to app.ens.domains and click on \"My Account\". Can I trade ENS domains on NFT exchanges? Yes, .eth names are tradeable as NFTs. How can I transfer domains registered in the .eth registry to someone else? You can do this using our Manager interface here, or using any tool with NFT support. What prohibits large scale domain grabbing besides registration fees? The cost of doing this is the only limitation in place. What is the \"registrant\" and \"controller\" of a name? The registrant is the account that owns the .eth name. They can transfer ownership to another account, and they can replace the controller address. The registrant is the owner of the NFT token that represents the name. The controller is the account that controls day-to-day operations with the name: creating subdomains, setting the resolver and records, and so forth. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"deploying-ens-on-a-private-chain.html":{"url":"deploying-ens-on-a-private-chain.html","title":"Deploying ENS on a Private Chain","keywords":"","body":"Deploying ENS on a Private Chain If you’d like to deploy ENS on your own network, or deploy your own copy of ENS on a public network, this guide shows you how. If you want to use an existing ENS deployment, see Resolving Names, Managing Names, and Registering & Renewing Names instead. On this page we will use Javascript, Web3, and Hardhat with npm for simplicity. You will find a complete migration file example at the bottom of this page. Please be aware that existing frameworks such as waffle and embark have support for local ENS deployment as well. Importing contracts The essential smart contracts are published as npm modules. You can install them in your npm project with npm install @ensdomains/ens-contracts. Now, you can require them in a migration script as follows (see the Truffle Documentation on working with contract artifacts and npm for details) import { ENS, ENSRegistry, PublicResolver } from '@ensdomains/ens-contracts' Including them within your smart contract is as follows import '@ensdomains/ens-contracts/contracts/registry/ENS.sol' ENS contains only an interface while ENSRegistry includes the actual implementation. Deploy the Registry The registry is ENS’s central component and stores, among other things, who owns which domain. This is the example using ethers and hardhat. const ENSRegistry = await ethers.getContractFactory(\"ENSRegistry\") await ENSRegistry.deploy() Once deployed, you will have a fresh ENS registry, whose root node is owned by the account that submitted the transaction. This account has total control over the ENS registry - it can create and replace any node in the entire tree. From here, it's possible to create and manage names by directly interacting with the registry, as described in Managing Names. However, you will probably want to deploy a resolver, and you may want to deploy a registrar so other users can register names. Deploy a Resolver Records in the registry can point to resolver contracts which store additional domain information. The most common use-case is to store an address for a domain, but storing a contract ABI or text is also possible. For most purposes on private networks it's convenient to have an unrestricted general-purpose resolver available. Deploying one is straightforward: const ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\"; const ENSRegistry = await ethers.getContractFactory(\"ENSRegistry\") const registry = await ENSRegistry.deploy() await registry.deployed() const PublicResolver = await ethers.getContractFactory(\"PublicResolver\") const resolver = await PublicResolver.deploy(registry.address, ZERO_ADDRESS); await resolver.deployed() The PublicResolver looks up ownership in the registry, which is why the registry's address is required at deployment. For ease of use, we can give this resolver a name: const ethers = require('ethers'); const utils = ethers.utils; const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const namehash = require('eth-ens-namehash'); async function setupResolver(ens, resolver, accounts) { const resolverNode = namehash.hash(\"resolver\"); const resolverLabel = labelhash(\"resolver\"); await ens.setSubnodeOwner(\"0x0000000000000000000000000000000000000000\", resolverLabel, accounts[0]); await ens.setResolver(resolverNode, resolver.address); await resolver.setAddr(resolverNode, resolver.address); } Above, we first create a new top-level domain, \"resolver\", then set its resolver address to our newly deployed public resolver. Finally, we set up an address record for \"resolver\", pointing back to the resolver address. In effect, the resolver is answering queries about its own address. After this, anyone can find the public resolver at the special ENS name \"resolver\". We call this function after deploying the public resolver in a .then() block as we did with the resolver. Deploy a Registrar So far, domains can only be registered manually by the owner of the registry's root node. Fortunately, contracts can also own nodes. This means we can set up a registrar contract as the owner of a node, e.g. \"test\", in the registry which enables it to distribute subdomains such as \"mycontract.test\". It allows us to have custom, on-chain logic which governs domain allocation. Once we own a (sub-)node we are free to repeat this process and set up another registrar. If you are part of the \"myorg\" organisation you could register \"myorg.test\" and let it point to your custom registrar which only allows certified members of your organisation to claim subdomains such as \"bob.myorg.test\". For our private network, we'll use the simple 'first come, first served' FIFSRegistrar, and set it as the owner of the top-level domain \"test\" in our migration script: ... const registrar = await FIFSRegistrar.deploy(ens.address, namehash.hash(\"test\")); await registrar.deployed(); await ens.setSubnodeOwner(\"0x0000000000000000000000000000000000000000\", sha3(\"test\"), registrar.address); }) ... Deploy the Reverse Registrar Similarly, if you wish to enable reverse resolution on your deployment, you will need to deploy the reverse registrar: ... const reverseRegistrar = await ReverseRegistrar.deploy(ens.address, resolver.address); await reverseRegistrar.deployed(); setupReverseRegistrar(ens, resolver, reverseRegistrar, accounts); ... async function setupReverseRegistrar(ens, resolver, reverseRegistrar, accounts) { await ens.setSubnodeOwner(\"0x0000000000000000000000000000000000000000\", utils.sha3(\"reverse\"), accounts[0]); await ens.setSubnodeOwner(namehash.hash(\"reverse\"), utils.sha3(\"addr\"), reverseRegistrar.address); } Migration File Example We can combine the steps above in a single hardhat migration file. This allows us to deploy ENS in one go: contracts/deps.sol //SPDX-License-Identifier: MIT // These imports are here to force Hardhat to compile contracts we depend on in our tests but don't need anywhere else. import \"@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol\"; import \"@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol\"; import \"@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol\"; ` script/deploy.js const hre = require(\"hardhat\"); const namehash = require('eth-ens-namehash'); const tld = \"test\"; const ethers = hre.ethers; const utils = ethers.utils; const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\"; const ZERO_HASH = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; async function main() { const ENSRegistry = await ethers.getContractFactory(\"ENSRegistry\") const FIFSRegistrar = await ethers.getContractFactory(\"FIFSRegistrar\") const ReverseRegistrar = await ethers.getContractFactory(\"ReverseRegistrar\") const PublicResolver = await ethers.getContractFactory(\"PublicResolver\") const signers = await ethers.getSigners(); const accounts = signers.map(s => s.address) const ens = await ENSRegistry.deploy() await ens.deployed() const resolver = await PublicResolver.deploy(ens.address, ZERO_ADDRESS); await resolver.deployed() await setupResolver(ens, resolver, accounts) const registrar = await FIFSRegistrar.deploy(ens.address, namehash.hash(tld)); await registrar.deployed() await setupRegistrar(ens, registrar); const reverseRegistrar = await ReverseRegistrar.deploy(ens.address, resolver.address); await reverseRegistrar.deployed() await setupReverseRegistrar(ens, registrar, reverseRegistrar, accounts); }; async function setupResolver(ens, resolver, accounts) { const resolverNode = namehash.hash(\"resolver\"); const resolverLabel = labelhash(\"resolver\"); await ens.setSubnodeOwner(ZERO_HASH, resolverLabel, accounts[0]); await ens.setResolver(resolverNode, resolver.address); await resolver['setAddr(bytes32,address)'](resolverNode, resolver.address); } async function setupRegistrar(ens, registrar) { await ens.setSubnodeOwner(ZERO_HASH, labelhash(tld), registrar.address); } async function setupReverseRegistrar(ens, registrar, reverseRegistrar, accounts) { await ens.setSubnodeOwner(ZERO_HASH, labelhash(\"reverse\"), accounts[0]); await ens.setSubnodeOwner(namehash.hash(\"reverse\"), labelhash(\"addr\"), reverseRegistrar.address); } // We recommend this pattern to be able to use async/await everywhere // and properly handle errors. main() .then(() => process.exit(0)) .catch((error) => { console.error(error); process.exit(1); }); To execute the migration file on hardhat, run the following command line. npx hardhat run scripts/deploy.js Deploying ENS in a single transaction Alternately you may wish to deploy a test registrar and its dependencies with a single transaction. This is useful for example in unit tests where you wish to start from a clean slate in each test. In many cases it will also be faster than sending a series of separate transactions. This can be done by deploying a new contract that creates and sets up all the other contracts in its constructor. The below code creates all the ENS contracts and assigns the eth TLD to the FIFS Registrar so that any eth domain may be registered in the unit tests. pragma solidity >=0.8.4; import {INameWrapper, PublicResolver} from '@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol'; import '@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol'; import '@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol'; import {NameResolver, ReverseRegistrar} from '@ensdomains/ens-contracts/contracts/registry/ReverseRegistrar.sol'; // Construct a set of test ENS contracts. contract ENSDeployer { bytes32 public constant TLD_LABEL = keccak256('eth'); bytes32 public constant RESOLVER_LABEL = keccak256('resolver'); bytes32 public constant REVERSE_REGISTRAR_LABEL = keccak256('reverse'); bytes32 public constant ADDR_LABEL = keccak256('addr'); ENSRegistry public ens; FIFSRegistrar public fifsRegistrar; ReverseRegistrar public reverseRegistrar; PublicResolver public publicResolver; function namehash(bytes32 node, bytes32 label) public pure returns (bytes32) { return keccak256(abi.encodePacked(node, label)); } constructor() public { ens = new ENSRegistry(); publicResolver = new PublicResolver(ens, INameWrapper(address(0))); // Set up the resolver bytes32 resolverNode = namehash(bytes32(0), RESOLVER_LABEL); ens.setSubnodeOwner(bytes32(0), RESOLVER_LABEL, address(this)); ens.setResolver(resolverNode, address(publicResolver)); publicResolver.setAddr(resolverNode, address(publicResolver)); // Create a FIFS registrar for the TLD fifsRegistrar = new FIFSRegistrar(ens, namehash(bytes32(0), TLD_LABEL)); ens.setSubnodeOwner(bytes32(0), TLD_LABEL, address(fifsRegistrar)); // Construct a new reverse registrar and point it at the public resolver reverseRegistrar = new ReverseRegistrar( ens, NameResolver(address(publicResolver)) ); // Set up the reverse registrar ens.setSubnodeOwner(bytes32(0), REVERSE_REGISTRAR_LABEL, address(this)); ens.setSubnodeOwner( namehash(bytes32(0), REVERSE_REGISTRAR_LABEL), ADDR_LABEL, address(reverseRegistrar) ); } } &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"dns-registrar-guide.html":{"url":"dns-registrar-guide.html","title":"DNS Registrar guide","keywords":"","body":"DNS Registrar guide Introduction DNSSEC (The Domain Name System Security Extensions) establishes a chain of trust from the root key which is signed by ICANN (.) and down through each key. Given DNSSEC is enabled and an ETH address is put into the subdomain of the domain you own (eg: _ens.yourdomain.tld), ENS manager allows anyone to submit the hash of the chain to DNSSEC Oracle smart contract Steps Step 1 Setting up DNSSEC signing When you first land on ENS manager, you will see something like below. .png>) If your DNS provider already supports DNSSEC-signed domains, all you do is enable the option on the DNS manager. If they don’t, you’ll need to migrate to someone who does. We recommend either EasyDNS or Google Cloud DNS. EasyDNS’s setup guide for DNSSEC is here, while Google’s is here. Whatever provider you need, make sure you select RSA signatures and SHA256 hashing. .png>) Step 2: Adding a TXT record The DNS Registrar on ENS looks for a TXT record with a specific name and format in order to verify what Ethereum address should be given ownership of the domain. To claim ownership of mydomain.xyz, create a TXT record in your DNS zone, _ens.mydomain.xyz, with text data of the form a=0x1234..., where 0x1234... is the Ethereum address you want to give control of the ENS record to. .png>) Step 3: Registering the name into ENS Once you get to this stage, you can complete the rest from ENS manager. Simply press \"Register\" and send the transaction. .png>) Step 4: Go to the manager .png>) FAQ Can I register any DNS domains through ENS app? Technically speaking, over 90% of domains can be supported. Some TLDs (.ceo, .art, .club, .luxe and .kred) are operated by each DNS registry. If I own myname.xyz DNS name, can I claim for myname.eth ? You may be confused with short name reservation process. Under DNSSEC integration, you can only claim for the correspondent ENS name with the same top level domain (TLD). .eth is managed completely separately. Once I register the domain, how can I transfer or delete ownership? Unlike .eth permanent registrar, there is no notion of registrant which can transfer the ownership of the controller. If you want to transfer the ownership to any address other than the currently registered address, please update the corresponding DNS record from your DNS manager and click \"Transfer\" from our ENS manager. We currently haven't enabled the ability to delete the ownership. Having said that, you can achieve the same effect if you set the owner record to a= 0x0000000000000000000000000000000000000000 then click \"Transfer\" from the ENS manager. Can I register my DNS subdomain? No. DNSSEC registration is only enabled for the second level domain (eg: yourname.xyz). If you want to create subdomain.yourname.xyz, then click \"Subdomains\" tab of our manager and create it from ENS manager just like other subdomains under .eth. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"bug-bounty-program.html":{"url":"bug-bounty-program.html","title":"Bug Bounty Program","keywords":"","body":"Bug Bounty Program The ENS bug bounty program rewards anyone who finds a bug in covered ENS smart contracts. Rules and Rewards Issues that have already been submitted by another user or are already known to the ENS team are not eligible for bounty rewards. Public disclosure of a vulnerability makes it ineligible for a bounty. This includes exploiting the bug on mainnet or any public test network. The ENS team, employees and all other people paid by ENS project, directly or indirectly, are not eligible for rewards. Only the smart contracts listed below are eligible for rewards. Websites and other infrastructure are not covered by the bounty program. The ENS bounty program considers a number of variables in determining rewards. Determinations of eligibility, score and all terms related to an award are at the sole and final discretion of the ENS team. The value of rewards paid out will vary depending on Severity. The severity is calculated according to the OWASP risk rating model based on Impact and Likelihood : .png>) Reward sizes are guided by the rules below, but are in the end, determined at the sole discretion of the ENS team Critical: up to $250,000 USD High: up to $150,000 USD Medium: up to $100,000 USD Low: up to $20,000 USD Note: up to $5,000 USD The ENS team reserves the right to adjust bounty amounts at any time in the future. Where the contract in our GitHub repository differs from the one deployed on Ethereum, due to changes having been made since the last deployment, the following rules apply: If the bug exists in the contract deployed on Ethereum, the full bounty amount is payable. If the bug is only in the version on GitHub, the ENS team will decide at is discretion an appropriate proportion of the bounty to award based on the state of the code (from 0% for code that was never intended to be deployed, to 100% for code that is considered final). In addition to Severity, other variables are also considered when the ENS team decides the score, including (but not limited to): Quality of description. Higher rewards are paid for clear, well-written submissions. Quality of reproducibility. Please include test code, scripts and detailed instructions. The easier it is for us to reproduce and verify the vulnerability, the higher the reward. Quality of fix, if included. Higher rewards are paid for submissions with clear description of how to fix the issue. Covered Contracts The following smart contracts are covered by the bounty: All non-test contracts in ensdomains/ens-contracts. ensdomains/name-wrapper. Important Legal Information The bug bounty program is a discretionary rewards program for the ENS community to encourage and reward those who are helping to improve the platform. It is not a competition. You should know that we can cancel the program at any time, and awards are at the sole discretion of the ENS team. In addition, we are not able to issue awards to individuals who are on sanctions lists or who are in countries on sanctions lists (e.g. North Korea, Iran, etc). You are responsible for all taxes. All awards are subject to applicable law. Any patches must be offered under the same license as the repository they affect. Finally, your testing must not violate any law or compromise any data that is not yours. Submitting a Bug Bugs should be submitted via email to bugs@ens.domains, or on Keybase to @arachnid. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/":{"url":"ens-improvement-proposals/","title":"ENS Improvement Proposals","summary":"Standards documentation describing the ENS protocol","keywords":"","body":"ENS Improvement Proposals &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-1-ens.html":{"url":"ens-improvement-proposals/ensip-1-ens.html","title":"ENSIP-1: ENS","summary":"Documentation of the basic ENS protocol (formerly EIP-137).","keywords":"","body":"ENSIP-1: ENS Author Nick Johnson \\arachnid@notdot.net Status Final Created 2016-04-04 Abstract This ENSIP describes the details of the Ethereum Name Service, a proposed protocol and ABI definition that provides flexible resolution of short, human-readable names to service and resource identifiers. This permits users and developers to refer to human-readable and easy to remember names, and permits those names to be updated as necessary when the underlying resource (contract, content-addressed data, etc) changes. The goal of domain names is to provide stable, human-readable identifiers that can be used to specify network resources. In this way, users can enter a memorable string, such as 'vitalik.wallet' or 'www.mysite.swarm', and be directed to the appropriate resource. The mapping between names and resources may change over time, so a user may change wallets, a website may change hosts, or a swarm document may be updated to a new version, without the domain name changing. Further, a domain need not specify a single resource; different record types allow the same domain to reference different resources. For instance, a browser may resolve 'mysite.swarm' to the IP address of its server by fetching its A (address) record, while a mail client may resolve the same address to a mail server by fetching its MX (mail exchanger) record. Motivation Existing specifications and implementations for name resolution in Ethereum provide basic functionality, but suffer several shortcomings that will significantly limit their long-term usefulness: A single global namespace for all names with a single 'centralised' resolver. Limited or no support for delegation and sub-names/sub-domains. Only one record type, and no support for associating multiple copies of a record with a domain. Due to a single global implementation, no support for multiple different name allocation systems. Conflation of responsibilities: Name resolution, registration, and whois information. Use-cases that these features would permit include: Support for subnames/sub-domains - eg, live.mysite.tld and forum.mysite.tld. Multiple services under a single name, such as a DApp hosted in Swarm, a Whisper address, and a mail server. Support for DNS record types, allowing blockchain hosting of 'legacy' names. This would permit an Ethereum client such as Mist to resolve the address of a traditional website, or the mail server for an email address, from a blockchain name. DNS gateways, exposing ENS domains via the Domain Name Service, providing easier means for legacy clients to resolve and connect to blockchain services. The first two use-cases, in particular, can be observed everywhere on the present-day internet under DNS, and we believe them to be fundamental features of a name service that will continue to be useful as the Ethereum platform develops and matures. The normative parts of this document does not specify an implementation of the proposed system; its purpose is to document a protocol that different resolver implementations can adhere to in order to facilitate consistent name resolution. An appendix provides sample implementations of resolver contracts and libraries, which should be treated as illustrative examples only. Likewise, this document does not attempt to specify how domains should be registered or updated, or how systems can find the owner responsible for a given domain. Registration is the responsibility of registrars, and is a governance matter that will necessarily vary between top-level domains. Updating of domain records can also be handled separately from resolution. Some systems, such as swarm, may require a well defined interface for updating domains, in which event we anticipate the development of a standard for this. Specification Overview The ENS system comprises three main parts: The ENS registry Resolvers Registrars The registry is a single contract that provides a mapping from any registered name to the resolver responsible for it, and permits the owner of a name to set the resolver address, and to create subdomains, potentially with different owners to the parent domain. Resolvers are responsible for performing resource lookups for a name - for instance, returning a contract address, a content hash, or IP address(es) as appropriate. The resolver specification, defined here and extended in other ENSIPs, defines what methods a resolver may implement to support resolving different types of records. Registrars are responsible for allocating domain names to users of the system, and are the only entities capable of updating the ENS; the owner of a node in the ENS registry is its registrar. Registrars may be contracts or externally owned accounts, though it is expected that the root and top-level registrars, at a minimum, will be implemented as contracts. Resolving a name in ENS is a two-step process. First, the ENS registry is called with the name to resolve, after hashing it using the procedure described below. If the record exists, the registry returns the address of its resolver. Then, the resolver is called, using the method appropriate to the resource being requested. The resolver then returns the desired result. For example, suppose you wish to find the address of the token contract associated with 'beercoin.eth'. First, get the resolver: var node = namehash(\"beercoin.eth\"); var resolver = ens.resolver(node); Then, ask the resolver for the address for the contract: var address = resolver.addr(node); Because the namehash procedure depends only on the name itself, this can be precomputed and inserted into a contract, removing the need for string manipulation, and permitting O(1) lookup of ENS records regardless of the number of components in the raw name. Name Syntax ENS names must conform to the following syntax: ::= | \".\" ::= any valid string label per [UTS46](https://unicode.org/reports/tr46/) In short, names consist of a series of dot-separated labels. Each label must be a valid normalised label as described in UTS46 with the options transitional=false and useSTD3AsciiRules=true. For Javascript implementations, a library is available that normalises and checks names. Note that while upper and lower case letters are allowed in names, the UTS46 normalisation process case-folds labels before hashing them, so two names with different case but identical spelling will produce the same namehash. Labels and domains may be of any length, but for compatibility with legacy DNS, it is recommended that labels be restricted to no more than 64 characters each, and complete ENS names to no more than 255 characters. For the same reason, it is recommended that labels do not start or end with hyphens, or start with digits. namehash algorithm Before being used in ENS, names are hashed using the 'namehash' algorithm. This algorithm recursively hashes components of the name, producing a unique, fixed-length string for any valid input domain. The output of namehash is referred to as a 'node'. Pseudocode for the namehash algorithm is as follows: def namehash(name): if name == '': return '\\0' * 32 else: label, _, remainder = name.partition('.') return sha3(namehash(remainder) + sha3(label)) Informally, the name is split into labels, each label is hashed. Then, starting with the last component, the previous output is concatenated with the label hash and hashed again. The first component is concatenated with 32 '0' bytes. Thus, 'mysite.swarm' is processed as follows: node = '\\0' * 32 node = sha3(node + sha3('swarm')) node = sha3(node + sha3('mysite')) Implementations should conform to the following test vectors for namehash: namehash('') = 0x0000000000000000000000000000000000000000000000000000000000000000 namehash('eth') = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae namehash('foo.eth') = 0xde9b09fd7c5f901e23a3f19fecc54828e9c848539801e86591bd9801b019f84f Registry specification The ENS registry contract exposes the following functions: function owner(bytes32 node) constant returns (address); Returns the owner (registrar) of the specified node. function resolver(bytes32 node) constant returns (address); Returns the resolver for the specified node. function ttl(bytes32 node) constant returns (uint64); Returns the time-to-live (TTL) of the node; that is, the maximum duration for which a node's information may be cached. function setOwner(bytes32 node, address owner); Transfers ownership of a node to another registrar. This function may only be called by the current owner of node. A successful call to this function logs the event Transfer(bytes32 indexed, address). function setSubnodeOwner(bytes32 node, bytes32 label, address owner); Creates a new node, sha3(node, label) and sets its owner to owner, or updates the node with a new owner if it already exists. This function may only be called by the current owner of node. A successful call to this function logs the event NewOwner(bytes32 indexed, bytes32 indexed, address). function setResolver(bytes32 node, address resolver); Sets the resolver address for node. This function may only be called by the owner of node. A successful call to this function logs the event NewResolver(bytes32 indexed, address). function setTTL(bytes32 node, uint64 ttl); Sets the TTL for a node. A node's TTL applies to the 'owner' and 'resolver' records in the registry, as well as to any information returned by the associated resolver. Resolver specification Resolvers may implement any subset of the record types specified here. Where a record types specification requires a resolver to provide multiple functions, the resolver MUST implement either all or none of them. Resolvers MUST specify a fallback function that throws. Resolvers have one mandatory function: function supportsInterface(bytes4 interfaceID) constant returns (bool) The supportsInterface function is documented in ENSIP-165, and returns true if the resolver implements the interface specified by the provided 4 byte identifier. An interface identifier consists of the XOR of the function signature hashes of the functions provided by that interface; in the degenerate case of single-function interfaces, it is simply equal to the signature hash of that function. If a resolver returns true for supportsInterface(), it must implement the functions specified in that interface. supportsInterface must always return true for 0x01ffc9a7, which is the interface ID of supportsInterface itself. Currently standardised resolver interfaces are specified in the table below. The following interfaces are defined: Interface name Interface hash Specification addr 0x3b3b57de Contract address name 0x691f3431 ENSIP-3 ABI 0x2203ab56 ENSIP-4 text 0x59d1d43c ENSIP-5 contenthash 0xbc1c58d1 ENSIP-7 interfaceImplementer 0xb8f2bbb4 ENSIP-8 addr(bytes32,uint256) 0xf1cb7e06 ENSIP-9 ENSIPs may define new interfaces to be added to this registry. Contract Address Interface Resolvers wishing to support contract address resources must provide the following function: function addr(bytes32 node) constant returns (address); If the resolver supports addr lookups but the requested node does not have an addr record, the resolver MUST return the zero address. Clients resolving the addr record MUST check for a zero return value, and treat this in the same manner as a name that does not have a resolver specified - that is, refuse to send funds to or interact with the address. Failure to do this can result in users accidentally sending funds to the 0 address. Changes to an address MUST trigger the following event: event AddrChanged(bytes32 indexed node, address a); Appendix A: Registry Implementation contract ENS { struct Record { address owner; address resolver; uint64 ttl; } mapping(bytes32=>Record) records; event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner); event Transfer(bytes32 indexed node, address owner); event NewResolver(bytes32 indexed node, address resolver); modifier only_owner(bytes32 node) { if(records[node].owner != msg.sender) throw; _ } function ENS(address owner) { records[0].owner = owner; } function owner(bytes32 node) constant returns (address) { return records[node].owner; } function resolver(bytes32 node) constant returns (address) { return records[node].resolver; } function ttl(bytes32 node) constant returns (uint64) { return records[node].ttl; } function setOwner(bytes32 node, address owner) only_owner(node) { Transfer(node, owner); records[node].owner = owner; } function setSubnodeOwner(bytes32 node, bytes32 label, address owner) only_owner(node) { var subnode = sha3(node, label); NewOwner(node, label, owner); records[subnode].owner = owner; } function setResolver(bytes32 node, address resolver) only_owner(node) { NewResolver(node, resolver); records[node].resolver = resolver; } function setTTL(bytes32 node, uint64 ttl) only_owner(node) { NewTTL(node, ttl); records[node].ttl = ttl; } } Appendix B: Sample Resolver Implementations Built-in resolver The simplest possible resolver is a contract that acts as its own name resolver by implementing the contract address resource profile: contract DoSomethingUseful { // Other code function addr(bytes32 node) constant returns (address) { return this; } function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de || interfaceID == 0x01ffc9a7; } function() { throw; } } Such a contract can be inserted directly into the ENS registry, eliminating the need for a separate resolver contract in simple use-cases. However, the requirement to 'throw' on unknown function calls may interfere with normal operation of some types of contract. Standalone resolver A basic resolver that implements the contract address profile, and allows only its owner to update records: contract Resolver { event AddrChanged(bytes32 indexed node, address a); address owner; mapping(bytes32=>address) addresses; modifier only_owner() { if(msg.sender != owner) throw; _ } function Resolver() { owner = msg.sender; } function addr(bytes32 node) constant returns(address) { return addresses[node]; } function setAddr(bytes32 node, address addr) only_owner { addresses[node] = addr; AddrChanged(node, addr); } function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de || interfaceID == 0x01ffc9a7; } function() { throw; } } After deploying this contract, use it by updating the ENS registry to reference this contract for a name, then calling setAddr() with the same node to set the contract address it will resolve to. Public resolver Similar to the resolver above, this contract only supports the contract address profile, but uses the ENS registry to determine who should be allowed to update entries: contract PublicResolver { event AddrChanged(bytes32 indexed node, address a); event ContentChanged(bytes32 indexed node, bytes32 hash); ENS ens; mapping(bytes32=>address) addresses; modifier only_owner(bytes32 node) { if(ens.owner(node) != msg.sender) throw; _ } function PublicResolver(address ensAddr) { ens = ENS(ensAddr); } function addr(bytes32 node) constant returns (address ret) { ret = addresses[node]; } function setAddr(bytes32 node, address addr) only_owner(node) { addresses[node] = addr; AddrChanged(node, addr); } function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de || interfaceID == 0x01ffc9a7; } function() { throw; } } Appendix C: Sample Registrar Implementation This registrar allows users to register names at no cost if they are the first to request them. contract FIFSRegistrar { ENS ens; bytes32 rootNode; function FIFSRegistrar(address ensAddr, bytes32 node) { ens = ENS(ensAddr); rootNode = node; } function register(bytes32 subnode, address owner) { var node = sha3(rootNode, subnode); var currentOwner = ens.owner(node); if(currentOwner != 0 && currentOwner != msg.sender) throw; ens.setSubnodeOwner(rootNode, subnode, owner); } } &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-2-initial-hash-registrar.html":{"url":"ens-improvement-proposals/ensip-2-initial-hash-registrar.html","title":"ENSIP-2: Initial Hash Registrar","summary":"Describes the hash registrar initially used to register ENS .eth domains (formerly EIP-162).","keywords":"","body":"ENSIP-2: Initial Hash Registrar Author Maurelian, Nick Johnson nick@ethereum.org, Alex Van de Sande avsa@ethereum.org Status Obsolete Created 2016-10-25 Abstract This ERC describes the implementation, as deployed to the main ethereum network on 2017-05-04, of a registrar contract to govern the allocation of names in the Ethereum Name Service (ENS). The corresponding source code is here. For more background, refer to ENSIP-1. Registrars are responsible for allocating domain names to users of the system, and are the only entities capable of updating the ENS; the owner of a node in the ENS registry is its registrar. Registrars may be contracts or externally owned accounts, though it is expected that the root and top-level registrars, at a minimum, will be implemented as contracts. - ENSIP-1 A well designed and governed registrar is essential to the success of the ENS described in ENSIP-1, but is described separately in this document as it is external to the core ENS protocol. In order to maximize utility and adoption of a new namespace, the registrar should mitigate speculation and \"name squatting\", however the best approach for mitigation is unclear. Thus an \"initial\" registrar is proposed, which implements a simple approach to name allocation. During the initial period, the available namespace will be significantly restricted to the .eth top level domain, and subdomain shorter than 7 characters in length disallowed. This specification largely describes @alexvandesande and @arachnid's hash registrar implementation in order to facilitate discussion. The intent is to replace the Initial Registrar contract with a permanent registrar contract. The Permanent Registrar will increase the available namespace, and incorporate lessons learned from the performance of the Initial Registrar. This upgrade is expected to take place within approximately 2 years of initial deployment. Motivations The following factors should be considered in order to optimize for adoption of the ENS, and good governance of the Initial Registrar's namespace. Upgradability: The Initial Registrar should be safely upgradeable, so that knowledge gained during its deployment can be used to replace it with an improved and permanent registrar. Effective allocation: Newly released namespaces often create a land grab situation, resulting in many potentially valuable names being purchased but unused, with the hope of re-selling at a profit. This reduces the availability of the most useful names, in turn decreasing the utility of the name service to end users. Achieving an effective allocation may or may not require human intervention for dispute resolution and other forms of curation. The Initial Registrar should not aim to create to most effective possible allocation, but instead limit the cost of misallocation in the long term. Security: The registrar will hold a balance of ether without an explicit limit. It must be designed securely. Simplicity: The ENS specification itself emphasizes a separation of concerns, allowing the most essential element, the registry to be as simple as possible. The interim registrar in turn should be as simple as possible while still meeting its other design goals. Adoption: Successful standards become more successful due to network effects. The registrar should consider what strategies will encourage the adoption of the ENS in general, and the namespace it controls in particular. Specification Initial restrictions The Initial Registrar is expected to be in service for approximately two years, prior to upgrading. This should be sufficient time to learn, observe, and design an updated system. During the initial two year period, the available name space will be restricted to the .eth TLD. This restriction is enforced by the owner of the ENS root node who should not assign any nodes other than .eth to the Initial Registrar. The ENS's root node should be controlled by multiple parties using a multisig contract. The Initial Registrar will also prohibit registration of names 6 characters or less in length. Name format for hash registration Names submitted to the initial registrar must be hashed using Ethereum's sha3 function. Note that the hashes submitted to the registrar are the hash of the subdomain label being registered, not the namehash as defined in ENSIP-1. For example, in order to register abcdefg.eth, one should submit sha3('abcdefg'), not sha3(sha3(0, 'eth'), 'abcdefg'). Auctioning names The registrar will allocate the available names through a Vickrey auction: A Vickrey auction is a type of sealed-bid auction. Bidders submit written bids without knowing the bid of the other people in the auction. The highest bidder wins but the price paid is the second-highest bid. This type of auction... gives bidders an incentive to bid their true value. - Vickrey Auction, Wikipedia The auction lifecycle of a name has 5 possible states, or Modes. Not-yet-available: The majority of names will be initially unavailable for auction, and will become available some time during the 8 weeks after launch. Open: The earliest availability for a name is determined by the most significant byte of its sha3 hash. 0x00 would become available immediately, 0xFF would become available after 8 weeks, and the availability of other names is distributed accordingly. Once a name is available, it is possible to start an auction on it. Auction: Once the auction for a name has begun, there is a 72 hour bidding period. Bidders must submit a payment of ether, along with sealed bids as a hash of sha3(bytes32 hash, address owner, uint value, bytes32 salt). The bidder may obfuscate the true bid value by sending a greater amount of ether. Reveal: After the bidding period, a 48 hour reveal period commences. During this time, bidders must reveal the true parameters of their sealed bid. As bids are revealed, ether payments are returned according to the schedule of \"refund ratios\" outlined in the table below. If no bids are revealed, the name will return to the Open state. Owned: After the reveal period has finished, the winning bidder must submit a transaction to finalize the auction, which then calls the ENS's setSubnodeOwner function, recording the winning bidder's address as the owner of the hash of the name. The following table outlines important parameters which define the Registrar's auction mechanism. Registrar Parameters Name Description Value totalAuctionLength The full time period from start of auction to end of the reveal period. 5 days revealPeriod The length of the time period during which bidding is no longer allowed, and bids must be revealed. 48 hours launchLength The time period during which all names will become available for auction. 8 weeks minPrice The minimum amount of ether which must be locked up in exchange for ownership of a name. 0.01 ether Deeds The Initial Registrar contract does not hold a balance itself. All ether sent to the Registrar will be held in a separate Deed contracts. A deed contract is first created and funded when a sealed bid is submitted. After an auction is completed and a hash is registered, the deed for the winning bid is held in exchange for ownership of the hash. Non-winning bids are refunded. A deed for an owned name may be transferred to another account by its owner, thus transferring ownership and control of the name. After 1 year of registration, the owner of a hash may choose to relinquish ownership and have the value of the deed returned to them. Deeds for non-winning bids can be closed by various methods, at which time any ether held will either be returned to the bidder, burnt, or sent to someone else as a reward for actions which help the registrar. The following table outlines what portion of the balance held in a deed contract will be returned upon closure, and to whom. The remaining balance will be burnt. Refund schedule Reason for Deed closure Refund Recipient Refund Percentage A valid non-winning bid is revealed. Bidder 99.5% A bid submitted after the auction period is revealed. Bidder 99.5% An otherwise valid bid is revealed on an owned name. 1 Bidder 0.5% An expired sealed bid is cancelled. 2 Canceler 0.5% A registered hash is reported as invalid. 3 Reporter 50% A registered hash is reported as invalid. 3 Owner 50% Notes: This incentivizes all bids to be revealed in time. If bids could be revealed late, an extortion attack on the current highest bidder could be made by threatening to reveal a new second highest bid. A bid which remains sealed after more than 2 weeks and 5 days may be cancelled by anyone to collect a small reward. Since names are hashed before auctioning and registration, the Initial Registrar is unable to enforce character length restrictions independently. A reward is therefore provided for reporting invalid names. Deployment and Upgrade process The Initial Registrar requires the ENS's address as a constructor, and should be deployed after the ENS. The multisig account owning the root node in the ENS should then set the Initial Registrar's address as owner of the eth node. The Initial Registrar is expected to be replaced by a Permanent Registrar approximately 2 years after deployment. The following process should be used for the upgrade: The Permanent Registrar contract will be deployed. The multisig account owning the root node in the ENS will assign ownership of the .eth node to the Permanent Registrar. Owners of hashes in the Initial Registrar will be responsible for registering their deeds to the Permanent Registrar. A couple options are considered here: Require owners to transfer their ownership prior to a cutoff date in order to maintain ownership and/or continue name resolution services. Have the Permanent Registrar query the Initial Registrar for ownership if it is lacking an entry. Planned deactivation In order to limit dependence on the Initial Registrar, new auctions will stop after 4 years, and all ether held in deeds after 8 years will become unreachable. Registrar Interface function state(bytes32 _hash) constant returns (Mode) Implements a state machine returning the current state of a name function entries(bytes32 _hash) constant returns (Mode, address, uint, uint, uint) Returns the following information regarding a registered name: state deed address registration date balance of the deed highest value bid at auction function getAllowedTime(bytes32 _hash) constant returns (uint timestamp) Returns the time at which the hash will no longer be in the initial not-yet-available state. function isAllowed(bytes32 _hash, uint _timestamp) constant returns (bool allowed) Takes a hash and a time, returns true if and only if it has passed the initial not-yet-available state. function startAuction(bytes32 _hash); Moves the state of a hash from Open to Auction. Throws if state is not Open. function startAuctions(bytes32[] _hashes); Starts multiple auctions on an array of hashes. This enables someone to open up an auction for a number of dummy hashes when they are only really interested in bidding for one. This will increase the cost for an attacker to simply bid blindly on all new auctions. Dummy auctions that are open but not bid on are closed after a week. function shaBid(bytes32 hash, address owner, uint value, bytes32 salt) constant returns (bytes32 sealedBid); Takes the parameters of a bid, and returns the sealedBid hash value required to participate in the bidding for an auction. This obfuscates the parameters in order to mimic the mechanics of placing a bid in an envelope. function newBid(bytes32 sealedBid); Bids are sent by sending a message to the main contract with a sealedBid hash and an amount of ether. The hash contains information about the bid, including the bidded name hash, the bid value, and a random salt. Bids are not tied to any one auction until they are revealed. The value of the bid itself can be masqueraded by sending more than the value of your actual bid. This is followed by a 48h reveal period. Bids revealed after this period will be burned and the ether unrecoverable. Since this is an auction, it is expected that most public hashes, like known domains and common dictionary words, will have multiple bidders pushing the price up. function startAuctionsAndBid(bytes32[] hashes, bytes32 sealedBid) A utility function allowing a call to startAuctions followed by newBid in a single transaction. function unsealBid(bytes32 _hash, address _owner, uint _value, bytes32 _salt); Once the bidding period is completed, there is a reveal period during with the properties of a bid are submitted to reveal them. The registrar hashes these properties using the shaBid() function above to verify that they match a pre-existing sealed bid. If the unsealedBid is the new best bid, the old best bid is returned to its bidder. function cancelBid(bytes32 seal); Cancels an unrevealed bid according to the rules described in the notes on the refund schedule above. function finalizeAuction(bytes32 _hash); After the registration date has passed, this function can be called to finalize the auction, which then calls the ENS function setSubnodeOwner() updating the ENS record to set the winning bidder as owner of the node. function transfer(bytes32 _hash, address newOwner); Update the owner of the ENS node corresponding to the submitted hash to a new owner. This function must be callable only by the current owner. function releaseDeed(bytes32 _hash); After some time, the owner can release the property and get their ether back. function invalidateName(string unhashedName); Since registration is done on the hash of a name, the registrar itself cannot validate names. This function can be used to report a name which is 6 characters long or less. If it has been registered, the submitter will earn 10% of the deed value. We are purposefully handicapping the simplified registrar as a way to force it into being restructured in a few years. function eraseNode(bytes32[] labels) Allows anyone to delete the owner and resolver records for a subdomain of a name that is not currently owned in the registrar. For instance, to zero foo.bar.eth on a registrar that owns .eth, pass an array containing [sha3('foo'), sha3('bar')]. function transferRegistrars(bytes32 _hash) onlyOwner(_hash); Used during the upgrade process to a permanent registrar. If this registrar is no longer the owner of the root node in the ENS, this function will transfer the deed to the current owner, which should be a new registrar. This function throws if this registrar still owns its root node. Rationale Starting with a temporary registrar Anticipating and designing for all the potential issues of name allocation names is unlikely to succeed. This approach chooses not to be concerned with getting it perfect, but allows us to observe and learn with training wheels on, and implement improvements before expanding the available namespace to shorter names or another TLD. Valid names >= 7 characters Preserving the shortest, and often most valuable, domain names for the upgraded registrar provides the opportunity to implement processes for dispute resolution (assuming they are found to be necessary). Delayed release of names A slower release allows for extra time to identify, and address any issues which may arise after launch. Restricting TLD to .eth Choosing a single TLD helps to maximize network effects by focusing on one namespace. A three letter TLD is a pattern made familiar by it's common usage in internet domain names. This familiarity significantly increases the potential of the ENS to be integrated into pre-existing DNS systems, and reserved as a special-use domain name. A recent precedent for this is the reservation of the .onion domain. Holding ether as collateral This approach is simpler than the familiar model of requiring owners to make recurring payments to retain ownership of a domain name. It also makes the initial registrar a revenue neutral service. Prior work This document borrows heavily from several sources: ENSIP-1 outlines the initial implementation of the Registry Contract (ENS.sol) and associated Resolver contracts. ERC-26 was the first ERC to propose a name service at the contract layer @alexvandesande's current implementation of the HashRegistrar Edits: 2016-10-26 Added link Alex's design in abstract 2016-11-01 change 'Planned deactivation' to h3' 2017-03-13 Update timelines for bidding and reveal periods Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-3-reverse-resolution.html":{"url":"ens-improvement-proposals/ensip-3-reverse-resolution.html","title":"ENSIP-3: Reverse Resolution","summary":"Specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS (formerly EIP-181).","keywords":"","body":"ENSIP-3: Reverse Resolution Author Nick Johnson \\nick@ens.domains Status Final Submitted 2016-12-01 Abstract This ENSIP specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS. This permits associating a human-readable name with any Ethereum blockchain address. Resolvers can be certain that the reverse record was published by the owner of the Ethereum address in question. Motivation While name services are mostly used for forward resolution - going from human-readable identifiers to machine-readable ones - there are many use-cases in which reverse resolution is useful as well: Applications that allow users to monitor accounts benefit from showing the name of an account instead of its address, even if it was originally added by address. Attaching metadata such as descriptive information to an address allows retrieving this information regardless of how the address was originally discovered. Anyone can configure a name to resolve to an address, regardless of ownership of that address. Reverse records allow the owner of an address to claim a name as authoritative for that address. Specification Reverse ENS records are stored in the ENS hierarchy in the same fashion as regular records, under a reserved domain, addr.reverse. To generate the ENS name for a given account's reverse records, convert the account to hexadecimal representation in lower-case, and append addr.reverse. For instance, the ENS registry's address at 0x112234455c3a32fd11230c42e7bccd4a84e02010 has any reverse records stored at 112234455c3a32fd11230c42e7bccd4a84e02010.addr.reverse. Note that this means that contracts wanting to do dynamic reverse resolution of addresses will need to perform hex encoding in the contract. Registrar The owner of the addr.reverse domain will be a registrar that permits the caller to take ownership of the reverse record for their own address. It provides the following methods: function claim(address owner) returns (bytes32 node) When called by account x, instructs the ENS registry to transfer ownership of the name hex(x) + '.addr.reverse' to the provided address, and return the namehash of the ENS record thus transferred. Allowing the caller to specify an owner other than themselves for the relevant node facilitates contracts that need accurate reverse ENS entries delegating this to their creators with a minimum of code inside their constructor: reverseRegistrar.claim(msg.sender) function claimWithResolver(address owner, address resolver) returns (bytes32 node) When called by account x, instructs the ENS registry to set the resolver of the name hex(x) + '.addr.reverse' to the specified resolver, then transfer ownership of the name to the provided address, and return the namehash of the ENS record thus transferred. This method facilitates setting up a custom resolver and owner in fewer transactions than would be required if calling claim. function setName(string name) returns (bytes32 node) When called by account x, sets the resolver for the name hex(x) + '.addr.reverse' to a default resolver, and sets the name record on that name to the specified name. This method facilitates setting up simple reverse records for users in a single transaction. Resolver interface A new resolver interface is defined, consisting of the following method: function name(bytes32 node) constant returns (string); Resolvers that implement this interface must return a valid ENS name for the requested node, or the empty string if no name is defined for the requested node. The interface ID of this interface is 0x691f3431. Future ENSIPs may specify more record types appropriate to reverse ENS records. Appendix 1: Registrar implementation This registrar, written in Solidity, implements the specifications outlined above. pragma solidity ^0.4.10; import \"./AbstractENS.sol\"; contract Resolver { function setName(bytes32 node, string name) public; } /** * @dev Provides a default implementation of a resolver for reverse records, * which permits only the owner to update it. */ contract DefaultReverseResolver is Resolver { AbstractENS public ens; mapping(bytes32=>string) public name; /** * @dev Constructor * @param ensAddr The address of the ENS registry. */ function DefaultReverseResolver(AbstractENS ensAddr) { ens = ensAddr; } /** * @dev Only permits calls by the reverse registrar. * @param node The node permission is required for. */ modifier owner_only(bytes32 node) { require(msg.sender == ens.owner(node)); _; } /** * @dev Sets the name for a node. * @param node The node to update. * @param _name The name to set. */ function setName(bytes32 node, string _name) public owner_only(node) { name[node] = _name; } } contract ReverseRegistrar { // namehash('addr.reverse') bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2; AbstractENS public ens; Resolver public defaultResolver; /** * @dev Constructor * @param ensAddr The address of the ENS registry. * @param resolverAddr The address of the default reverse resolver. */ function ReverseRegistrar(AbstractENS ensAddr, Resolver resolverAddr) { ens = ensAddr; defaultResolver = resolverAddr; } /** * @dev Transfers ownership of the reverse ENS record associated with the * calling account. * @param owner The address to set as the owner of the reverse record in ENS. * @return The ENS node hash of the reverse record. */ function claim(address owner) returns (bytes32 node) { return claimWithResolver(owner, 0); } /** * @dev Transfers ownership of the reverse ENS record associated with the * calling account. * @param owner The address to set as the owner of the reverse record in ENS. * @param resolver The address of the resolver to set; 0 to leave unchanged. * @return The ENS node hash of the reverse record. */ function claimWithResolver(address owner, address resolver) returns (bytes32 node) { var label = sha3HexAddress(msg.sender); node = sha3(ADDR_REVERSE_NODE, label); var currentOwner = ens.owner(node); // Update the resolver if required if(resolver != 0 && resolver != ens.resolver(node)) { // Transfer the name to us first if it's not already if(currentOwner != address(this)) { ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, this); currentOwner = address(this); } ens.setResolver(node, resolver); } // Update the owner if required if(currentOwner != owner) { ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner); } return node; } /** * @dev Sets the `name()` record for the reverse ENS record associated with * the calling account. First updates the resolver to the default reverse * resolver if necessary. * @param name The name to set for this address. * @return The ENS node hash of the reverse record. */ function setName(string name) returns (bytes32 node) { node = claimWithResolver(this, defaultResolver); defaultResolver.setName(node, name); return node; } /** * @dev Returns the node hash for a given account's reverse records. * @param addr The address to hash * @return The ENS node hash. */ function node(address addr) constant returns (bytes32 ret) { return sha3(ADDR_REVERSE_NODE, sha3HexAddress(addr)); } /** * @dev An optimised function to compute the sha3 of the lower-case * hexadecimal representation of an Ethereum address. * @param addr The address to hash * @return The SHA3 hash of the lower-case hexadecimal encoding of the * input address. */ function sha3HexAddress(address addr) private returns (bytes32 ret) { addr; ret; // Stop warning us about unused variables assembly { let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000 let i := 40 loop: i := sub(i, 1) mstore8(i, byte(and(addr, 0xf), lookup)) addr := div(addr, 0x10) i := sub(i, 1) mstore8(i, byte(and(addr, 0xf), lookup)) addr := div(addr, 0x10) jumpi(loop, i) ret := sha3(0, 40) } } } Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-4-support-for-contract-abis.html":{"url":"ens-improvement-proposals/ensip-4-support-for-contract-abis.html","title":"ENSIP-4: Support for contract ABIs","summary":"A mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers (formerly EIP-205).","keywords":"","body":"ENSIP-4: Support for contract ABIs Author Nick Johnson \\nick@ens.domains Status Final Submitted 2017-02-06 Abstract ABIs are important metadata required for interacting with most contracts. At present, they are typically supplied out-of-band, which adds an additional burden to interacting with contracts, particularly on a one-off basis or where the ABI may be updated over time. The small size of ABIs permits an alternative solution, storing them in ENS, permitting name lookup and ABI discovery via the same process. ABIs are typically quite compact; the largest in-use ABI we could find, that for the DAO, is 9450 bytes uncompressed JSON, 6920 bytes uncompressed CBOR, and 1128 bytes when the JSON form is compressed with zlib. Further gains on CBOR encoding are possible using a CBOR extension that permits eliminating repeated strings, which feature extensively in ABIs. Most ABIs, however, are far shorter than this, consisting of only a few hundred bytes of uncompressed JSON. This ENSIP defines a resolver profile for retrieving contract ABIs, as well as encoding standards for storing ABIs for different applications, allowing the user to select between different representations based on their need for compactness and other considerations such as onchain access. Specification ABI encodings In order to allow for different tradeoffs between onchain size and accessibility, several ABI encodings are defined. Each ABI encoding is defined by a unique constant with only a single bit set, allowing for the specification of 256 unique encodings in a single uint. The currently recognised encodings are: ID Description 1 JSON 2 zlib-compressed JSON 4 CBOR 8 URI This table may be extended in future through the ENSIP process. Encoding type 1 specifies plaintext JSON, uncompressed; this is the standard format in which ABIs are typically encoded, but also the bulkiest, and is not easily parseable onchain. Encoding type 2 specifies zlib-compressed JSON. This is significantly smaller than uncompressed JSON, and is straightforward to decode offchain. However, it is impractical for onchain consumers to use. Encoding type 4 is CBOR. CBOR is a binary encoding format that is a superset of JSON, and is both more compact and easier to parse in limited environments such as the EVM. Consumers that support CBOR are strongly encouraged to also support the stringref extension to CBOR, which provides significant additional reduction in encoded size. Encoding type 8 indicates that the ABI can be found elsewhere, at the specified URI. This is typically the most compact of the supported forms, but also adds external dependencies for implementers. The specified URI may use any schema, but HTTP, IPFS, and Swarm are expected to be the most common. Resolver profile A new resolver interface is defined, consisting of the following method: function ABI(bytes32 node, uint256 contentType) constant returns (uint256, bytes); The interface ID of this interface is 0x2203ab56. contentType is a bitfield, and is the bitwise OR of all the encoding types the caller will accept. Resolvers that implement this interface must return an ABI encoded using one of the requested formats, or (0, \"\") if they do not have an ABI for this function, or do not support any of the requested formats. The abi resolver profile is valid on both forward and reverse records. ABI lookup process When attempting to fetch an ABI based on an ENS name, implementers should first attempt an ABI lookup on the name itself. If that lookup returns no results, they should attempt a reverse lookup on the Ethereum address the name resolves to. Implementers should support as many of the ABI encoding formats as practical. Rationale Storing ABIs onchain avoids the need to introduce additional dependencies for applications wishing to fetch them, such as swarm or HTTP access. Given the typical compactness of ABIs, we believe this is a worthwhile tradeoff in many cases. The two-step resolution process permits different names to provide different ABIs for the same contract, such as in the case where it's useful to provide a minimal ABI to some callers, as well as specifying ABIs for contracts that did not specify one of their own. The fallback to looking up an ABI on the reverse record permits contracts to specify their own canonical ABI, and prevents the need for duplication when multiple names reference the same contract without the need for different ABIs. Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-5-text-records.html":{"url":"ens-improvement-proposals/ensip-5-text-records.html","title":"ENSIP-5: Text Records","summary":"A standard for storage of text records in ENS (formerly EIP-634).","keywords":"","body":"ENSIP-5: Text Records Author Richard Moore (@ricmoo) Status Final Submitted 2017-05-17 Abstract This ENSIP defines a resolver profile for ENS that permits the lookup of arbitrary key-value text data. This allows ENS name holders to associate e-mail addresses, URLs and other informational data with a ENS name. Motivation There is often a desire for human-readable metadata to be associated with otherwise machine-driven data; used for debugging, maintenance, reporting and general information. In this ENSIP we define a simple resolver profile for ENS that permits ENS names to associate arbitrary key-value text. Specification Resolver Profile A new resolver interface is defined, consisting of the following method: interface IERC634 { /// @notice Returns the text data associated with a key for an ENS name /// @param node A nodehash for an ENS name /// @param key A key to lookup text data for /// @return The text data function text(bytes32 node, string key) view returns (string text); } The EIP-165 interface ID of this interface is 0x59d1d43c. The text data may be any arbitrary UTF-8 string. If the key is not present, the empty string must be returned. Global Keys Global Keys must be made up of lowercase letters, numbers and the hyphen (-). avatar - a URL to an image used as an avatar or logo description - A description of the name display - a canonical display name for the ENS name; this MUST match the ENS name when its case is folded, and clients should ignore this value if it does not (e.g. \"ricmoo.eth\" could set this to \"RicMoo.eth\") email - an e-mail address keywords - A list of comma-separated keywords, ordered by most significant first; clients that interpresent this field may choose a threshold beyond which to ignore mail - A physical mailing address notice - A notice regarding this name location - A generic location (e.g. \"Toronto, Canada\") phone - A phone number as an E.164 string url - a website URL Service Keys Service Keys must be made up of a reverse dot notation for a namespace which the service owns, for example, DNS names (e.g. .com, .io, etc) or ENS name (i.e. .eth). Service Keys must contain at least one dot. This allows new services to start using their own keys without worrying about colliding with existing services and also means new services do not need to update this document. The following services are common, which is why recommendations are provided here, but ideally a service would declare its own key. com.github - a GitHub username com.peepeth - a Peepeth username com.linkedin - a LinkedIn username com.twitter - a Twitter username io.keybase - a Keybase username org.telegram - a Telegram username This technique also allows for a service owner to specify a hierarchy for their keys, such as: com.example.users com.example.groups com.example.groups.public com.example.groups.private Legacy Keys The following keys were specified in earlier versions of this ENSIP. Their use is not likely very wide, but applications attempting maximal compatibility may wish to query these keys as a fallback if the above replacement keys fail. vnd.github - a GitHub username (renamed to com.github) vnd.peepeth - a peepeth username (renamed to com.peepeth) vnd.twitter - a Twitter username (renamed to com.twitter) Rationale Application-specific vs general-purpose record types Rather than define a large number of specific record types (each for generally human-readable data) such as url and email, we follow an adapted model of DNS's TXT records, which allow for a general keys and values, allowing future extension without adjusting the resolver, while allowing applications to use custom keys for their own purposes. Backwards Compatibility Not applicable. Security Considerations None. Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-6-dns-in-ens.html":{"url":"ens-improvement-proposals/ensip-6-dns-in-ens.html","title":"ENSIP-6: DNS-in-ENS","summary":"Defines a resolver profile for ENS that provides features for storage and lookup of DNS records (formerly EIP-1185).","keywords":"","body":"ENSIP-6: DNS-in-ENS This standard is obsolete, and does not reflect the current implementation. Author Jim McDonald (@mcdee) Status Stagnant Created 2018-06-26 Abstract This ENSIP defines a resolver profile for ENS that provides features for storage and lookup of DNS records. This allows ENS to be used as a store of authoritative DNS information. Motivation ENS is a highly desirable store for DNS information. It provides the distributed authority of DNS without conflating ownership and authoritative serving of information. With ENS, the owner of a domain has full control over their own DNS records. Also, ENS has the ability (through smart contracts) for a domain's subdomains to be irrevocably assigned to another entity. Specification The resolver profile to support DNS on ENS follows the resolver specification as defined in #137. Traditionally, DNS is a zone-based system in that all of the records for a zone are kept together in the same file. This has the benefit of simplicity and atomicity of zone updates, but when transposed to ENS can result in significant gas costs for simple changes. As a result, the resolver works on the basis of record sets. A record set is uniquely defined by the tuple (domain, name, resource record type), for example the tuple (example.com, www.example.com, A) defines the record set of A records for the name www.example.com in the domain example.com. A record set can contain 0 or more values, for example if www.example.com has A records 1.2.3.4 and 5.6.7.8 then the aforementioned tuple will have two values. The choice to work at the level of record sets rather than zones means that this specification cannot completely support some features of DNS, such as zone transfers and DNSSEC. It would be possible to build a different resolver profile that works at the zone level, however it would be very expensive to carry out updates and so is not considered further for this ENSIP. The DNS resolver interface consists of two functions to set DNS information and two functions to query DNS information. setDNSRecords(bytes32 node, bytes data) setDNSRecords() sets, updates or clears 1 or more DNS records for a given node. It has function signature 0x0af179d7. The arguments for the function are as follows: node: the namehash of the fully-qualified domain in ENS for which to set the records. Namehashes are defined in #137 data: 1 or more DNS records in DNS wire format. Any record that is supplied without a value will be cleared. Note that all records in the same RRset should be contiguous within the data; if not then the later RRsets will overwrite the earlier one(s) clearDNSZone(bytes32 node) clearDNSZone() removes all DNS records for the domain. It has function signature 0xad5780af. Although it is possible to clear records individually with setDNSRecords() as described above this requires the owner to know all of the records that have been set (as the resolver has no methods to iterate over the records for a given domain), and might require multiple transactions. clearDNSZone() removes all zone information in a single operation. The arguments for the function is as follows: node: the namehash of the fully-qualified domain in ENS for which to clear the records. Namehashes are defined in #137 dnsRecords(bytes32 node, bytes32 name, uint16 resource) view returns (bytes) dnsRecords() obtains the DNS records for a given node, name and resource. It has function signature 0x2461e851. The arguments for the function are as follows: node: the namehash of the fully-qualified domain in ENS for which to set the records. Namehashes are defined in #137 name: the keccak256() hash of the name of the record in DNS wire format. resource: the resource record ID. Resource record IDs are defined in https://en.wikipedia.org/wiki/List\\_of\\_DNS\\_record\\_types The function returns all matching records in DNS wire format. If there are no records present the function will return nothing. hasDNSRecords(bytes32 node, bytes32 name) view returns (bool) hasDNSRecords() reports if there are any records for the provided name in the domain. It has function signature 0x4cbf6ba4. This function is needed by DNS resolvers when working with wildcard resources as defined in https://tools.ietf.org/html/rfc4592 The arguments for the function are as follows: node: the namehash of the fully-qualified domain in ENS for which to set the records. Namehashes are defined in #137 name: the keccak256() hash of the name of the record in DNS wire format. The function returns true if there are any records for the provided node and name, otherwise false. Backwards compatibility Not applicable. Implementation The reference implementation of the DNS resolver is at https://github.com/wealdtech/wealdtech-solidity/blob/master/contracts/ens/DNSResolver.sol https://github.com/wealdtech/ethereal.git can be used to test the functionality of the resolver with the \"dns set\", \"dns get\" and \"dns clear\" commands. Test Cases Test cases for the DNS resolver are at https://github.com/wealdtech/wealdtech-solidity/blob/master/test/ens/DNSResolver.js Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-18 18:35:50 "},"ens-improvement-proposals/ensip-7-contenthash-field.html":{"url":"ens-improvement-proposals/ensip-7-contenthash-field.html","title":"ENSIP-7: Contenthash field","summary":"Introduces a field for storing content addresses and hashes in ENS (formerly EIP-1577).","keywords":"","body":"ENSIP-7: Contenthash field Author Dean Eigenmann [dean@ens.domains](mailto:dean@ens.domains), Nick Johnson [nick@ens.domains](mailto:nick@ens.domains) Status Final Created 2018-11-13 Abstract This ENSIP introduces the new contenthash field for ENS resolvers, allowing for a better defined system of mapping names to network and content addresses. Additionally the content and multihash fields are deprecated. Motivation Multiple applications including Metamask and mobile clients such as Status have begun resolving ENS names to content hosted on distributed systems such as IPFS and Swarm. Due to the various ways content can be stored and addressed, a standard is required so these applications know how to resolve names and that domain owners know how their content will be resolved. The contenthash field allows for easy specification of network and content addresses in ENS. Specification The field contenthash is introduced, which permits a wide range of protocols to be supported by ENS names. Resolvers supporting this field MUST return true when the supportsInterface function is called with argument 0xbc1c58d1. The fields content and multihash are deprecated. The value returned by contenthash MUST be represented as a machine-readable multicodec. The format is specified as follows: protoCodes and their meanings are specified in the multiformats/multicodec repository. The encoding of the value depends on the content type specified by the protoCode. Values with protocodes of 0xe3 and 0xe4 represent IPFS and Swarm content; these values are encoded as v1 CIDs without a base prefix, meaning their value is formatted as follows: When resolving a contenthash, applications MUST use the protocol code to determine what type of address is encoded, and resolve the address appropriately for that protocol, if supported. Example IPFS Input data: storage system: IPFS (0xe3) CID version: 1 (0x01) content type: dag-pb (0x70) hash function: sha2-256 (0x12) hash length: 32 bytes (0x20) hash: 29f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1f Binary format: 0xe3010170122029f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1f Text format: ipfs://QmRAQB6YaCyidP37UdDnjFY5vQuiBrcqdyoW1CuDgwxkD4 Swarm Input data: storage system: Swarm (0xe4) CID version: 1 (0x01) content type: swarm-manifest (0xfa) hash function: keccak256 (0x1b) hash length: 32 bytes (0x20) hash: d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162 Binary format: 0xe40101fa011b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162 Text format: bzz://d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162 Example usage with swarm hash: $ swarm hash ens contenthash d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162 > e40101fa011b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162 Fallback In order to support names that have an IPFS or Swarm hash in their content field, a grace period MUST be implemented offering those name holders time to update their names. If a resolver does not support the multihash interface, it MUST be checked whether they support the content interface. If they do, the value of that field SHOULD be treated in a context dependent fashion and resolved. This condition MUST be enforced until at least March 31st, 2019. Implementation To support contenthash, a new resolver has been developed and can be found here, you can also find this smart contract deployed on: Mainnet : 0xd3ddccdd3b25a8a7423b5bee360a42146eb4baf3 Ropsten : 0xde469c7106a9fbc3fb98912bb00be983a89bddca There are also implementations in multiple languages to encode and decode contenthash: JavaScript Python Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-8-interface-discovery.html":{"url":"ens-improvement-proposals/ensip-8-interface-discovery.html","title":"ENSIP-8: Interface Discovery","summary":"Defines a method of associating contract interfaces with ENS names and addresses, and of discovering those interfaces (formerly EIP-1844).","keywords":"","body":"ENSIP-8: Interface Discovery Author Nick Johnson \\nick@ens.domains Status Final Submitted 2019-03-05 Abstract This ENSIP specifies a method for exposing interfaces associated with an ENS name or an address (typically a contract address) and allowing applications to discover those interfaces and interact with them. Interfaces can be implemented either by the target contract (if any) or by any other contract. Motivation EIP 165 supports interface discovery - determining if the contract at a given address supports a requested interface. However, in many cases it's useful to be able to discover functionality associated with a name or an address that is implemented by other contracts. For example, a token contract may not itself provide any kind of 'atomic swap' functionality, but there may be associated contracts that do. With ENS interface discovery, the token contract can expose this metadata, informing applications where they can find that functionality. Specification A new profile for ENS resolvers is defined, consisting of the following method: function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address); The EIP-165 interface ID of this interface is 0xb8f2bbb4. Given an ENS name hash node and an EIP-165 interfaceID, this function returns the address of an appropriate implementer of that interface. If there is no interface matching that interface ID for that node, 0 is returned. The address returned by interfaceImplementer MUST refer to a smart contract. The smart contract at the returned address SHOULD implement EIP-165. Resolvers implementing this interface MAY utilise a fallback strategy: If no matching interface was explicitly provided by the user, query the contract returned by addr(), returning its address if the requested interface is supported by that contract, and 0 otherwise. If they do this, they MUST ensure they return 0, rather than reverting, if the target contract reverts. This field may be used with both forward resolution and reverse resolution. Rationale A naive approach to this problem would involve adding this method directly to the target contract. However, doing this has several shortcomings: Each contract must maintain its own list of interface implementations. Modifying this list requires access controls, which the contract may not have previously required. Support for this must be designed in when the contract is written, and cannot be retrofitted afterwards. Only one canonical list of interfaces can be supported. Using ENS resolvers instead mitigates these shortcomings, making it possible for anyone to associate interfaces with a name, even for contracts not previously built with this in mind. Backwards Compatibility There are no backwards compatibility issues. Implementation The PublicResolver in the ensdomains/resolvers repository implements this interface. Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-9-multichain-address-resolution.html":{"url":"ens-improvement-proposals/ensip-9-multichain-address-resolution.html","title":"ENSIP-9: Multichain Address Resolution","summary":"Introduces new overloads for the `addr` field for ENS resolvers, which permit resolution of addresses for other blockchains via ENS (formerly EIP-2304).","keywords":"","body":"ENSIP-9: Multichain Address Resolution Author Nick Johnson \\nick@ens.domains Status Final Submitted 2019-09-09 Motivation With the increasing uptake of ENS by multi-coin wallets, wallet authors have requested the ability to resolve addresses for non-Ethereum chains inside ENS. This specification standardises a way to enter and retrieve these addresses in a cross-client fashion. Specification A new accessor function for resolvers is specified: function addr(bytes32 node, uint coinType) external view returns(bytes memory); The EIP165 interface ID for this function is 0xf1cb7e06. When called on a resolver, this function must return the cryptocurrency address for the specified namehash and coin type. A zero-length string must be returned if the specified coin ID does not exist on the specified node. coinType is the cryptocurrency coin type index from SLIP44. The return value is the cryptocurrency address in its native binary format. Detailed descriptions of the binary encodings for several popular chains are provided in the Address Encoding section below. A new event for resolvers is defined: event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress); Resolvers MUST emit this event on each change to the address for a name and coin type. Recommended accessor functions The following function provides the recommended interface for changing the addresses stored for a node. Resolvers SHOULD implement this interface for setting addresses unless their needs dictate a different interface. function setAddr(bytes32 node, uint coinType, bytes calldata addr); setAddr adds or replaces the address for the given node and coin type. The parameters for this function are as per those described in addr() above. This function emits an AddressChanged event with the new address; see also the backwards compatibility section below for resolvers that also support addr(bytes32). Address Encoding In general, the native binary representation of the address should be used, without any checksum commonly used in the text representation. A table of encodings for common blockchains is provided, followed by a more detailed description of each format. In the table, 'encodings' lists the address encodings supported by that chain, along with any relevant parameters. Details of those address encodings are described in the following sections. Cryptocurrency Coin Type Encoding Bitcoin 0 P2PKH(0x00), P2SH(0x05), SegWit('bc') Litecoin 2 P2PKH(0x30), P2SH(0x32), P2SH(0x05), SegWit('ltc') Dogecoin 3 P2PKH(0x1e), P2SH(0x16) Monacoin 22 P2PKH(0x32), P2SH(0x05) Ethereum 60 ChecksummedHex Ethereum Classic 61 ChecksummedHex Rootstock 137 ChecksummedHex(30) Ripple 144 Ripple Bitcoin Cash 145 P2PKH(0x00), P2SH(0x05), CashAddr Binance 714 Bech32('bnb') P2PKH(version) Pay to Public Key Hash addresses are base58check encoded. After decoding, the first byte is a version byte. For example, the Bitcoin address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa base58check decodes to the 21 bytes 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18. P2PKH addresses have a version byte, followed by a 20 byte pubkey hash. Their canonical encoding is their scriptPubkey encoding (specified here) is OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG. The above example address is thus encoded as the 25 bytes 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac. P2SH(version) P2SH addresses are base58check encoded in the same manner as P2PKH addresses. P2SH addresses have a version, followed by a 20 byte script hash. Their scriptPubkey encoding (specified here) is OP_HASH160 OP_EQUAL. A Bitcoin address of 3Ai1JZ8pdJb2ksieUV8FsxSNVJCpoPi8W6 decodes to the 21 bytes 0562e907b15cbf27d5425399ebf6f0fb50ebb88f18 and is encoded as the 23 bytes a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1887. SegWit(hrp) SegWit addresses are encoded with bech32. Bech32 addresses consist of a human-readable part - 'bc' for Bitcoin mainnet - and a machine readable part. For SegWit addresses, this decodes to a 'witness version', between 0 and 15, and a 'witness program', as defined in BIP141. The scriptPubkey encoding for a bech32 address, as defined in BIP141, is OP_n, where n is the witness version, followed by a push of the witness program. Note this warning from BIP173: Implementations should take special care when converting the address to a scriptPubkey, where witness version n is stored as OP_n. OP_0 is encoded as 0x00, but OP_1 through OP_16 are encoded as 0x51 though 0x60 (81 to 96 in decimal). If a bech32 address is converted to an incorrect scriptPubKey the result will likely be either unspendable or insecure. For example, the Bitcoin SegWit address BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4 decodes to a version of 0 and a witness script of 751e76e8199196d454941c45d1b3a323f1433bd6, and then encodes to a scriptPubkey of 0014751e76e8199196d454941c45d1b3a323f1433bd6. ChecksummedHex(chainId?) To translate a text format checksummed hex address into binary format, simply remove the '0x' prefix and hex decode it. 0x314159265dD8dbb310642f98f50C066173C1259b is hex-decoded and stored as the 20 bytes 314159265dd8dbb310642f98f50c066173c1259b. A checksum format is specified by EIP-55, and extended by RSKIP60, which specifies a means of including the chain ID in the checksum. The checksum on a text format address must be checked. Addresses with invalid checksums that are not all uppercase or all lowercase MUST be rejected with an error. Implementations may choose whether to accept non-checksummed addresses, but the authors recommend at least providing a warning to users in this situation. When encoding an address from binary to text, an EIP55/RSKIP60 checksum MUST be used - so the correct encoding of the above address for Ethereum is 0x314159265dD8dbb310642f98f50C066173C1259b. Ripple Ripple addresses are encoded using a version of base58check with an alternative alphabet, described here. Two types of ripple addresses are supported, 'r-addresses', and 'X-addresss'. r-addresses consist of a version byte followed by a 20 byte hash, while X-addresses consist of a version byte, a 20 byte hash, and a tag, specified here. Both address types should be stored in ENS by performing ripple's version of base58check decoding and storing them directly (including version byte). For example, the ripple address rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn decodes to and is stored as 004b4e9c06f24296074f7bc48f92a97916c6dc5ea9, while the address X7qvLs7gSnNoKvZzNWUT2e8st17QPY64PPe7zriLNuJszeg decodes to and is stored as 05444b4e9c06f24296074f7bc48f92a97916c6dc5ea9000000000000000000. CashAddr Bitcoin Cash defines a new address format called 'CashAddr', specified here. This uses a variant of bech32 encoding to encode and decode (non-segwit) Bitcoin Cash addresses, using a prefix of 'bitcoincash:'. A CashAddr should be decoded using this bech32 variant, then converted and stored based on its type (P2PKH or P2SH) as described in the relevant sections above. Bech32 Bech32 addresses consist of a human-readable part - for example, 'bnb' for Binance - and a machine readable part. The encoded data is simply the address, which can be converted to binary and stored directly. For example, the BNB address bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 decodes to the binary representation 40c2979694bbc961023d1d27be6fc4d21a9febe6, which is stored directly in ENS. Example An example implementation of a resolver that supports this ENSIP is provided here: pragma solidity ^0.5.8; contract AddrResolver is ResolverBase { bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de; bytes4 constant private ADDRESS_INTERFACE_ID = 0xf1cb7e06; uint constant private COIN_TYPE_ETH = 60; event AddrChanged(bytes32 indexed node, address a); event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress); mapping(bytes32=>mapping(uint=>bytes)) _addresses; /** * Sets the address associated with an ENS node. * May only be called by the owner of that node in the ENS registry. * @param node The node to update. * @param a The address to set. */ function setAddr(bytes32 node, address a) external authorised(node) { setAddr(node, COIN_TYPE_ETH, addressToBytes(a)); } /** * Returns the address associated with an ENS node. * @param node The ENS node to query. * @return The associated address. */ function addr(bytes32 node) public view returns (address) { bytes memory a = addr(node, COIN_TYPE_ETH); if(a.length == 0) { return address(0); } return bytesToAddress(a); } function setAddr(bytes32 node, uint coinType, bytes memory a) public authorised(node) { emit AddressChanged(node, coinType, a); if(coinType == COIN_TYPE_ETH) { emit AddrChanged(node, bytesToAddress(a)); } _addresses[node][coinType] = a; } function addr(bytes32 node, uint coinType) public view returns(bytes memory) { return _addresses[node][coinType]; } function supportsInterface(bytes4 interfaceID) public pure returns(bool) { return interfaceID == ADDR_INTERFACE_ID || interfaceID == ADDRESS_INTERFACE_ID || super.supportsInterface(interfaceID); } } Implementation An implementation of this interface is provided in the ensdomains/resolvers repository. Backwards Compatibility If the resolver supports the addr(bytes32) interface defined in ENSIP-1, the resolver MUST treat this as a special case of this new specification in the following ways: The value returned by addr(node) from ENSIP-1 should always match the value returned by addr(node, 60) (60 is the coin type ID for Ethereum). Anything that causes the AddrChanged event from ENSIP-1 to be emitted must also emit an AddressChanged event from this ENSIP, with the coinType specified as 60, and vice-versa. Tests The table below specifies test vectors for valid address encodings for each cryptocurrency described above. Cryptocurrency Coin Type Text Onchain (hex) Bitcoin 0 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac 3Ai1JZ8pdJb2ksieUV8FsxSNVJCpoPi8W6 a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1887 BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4 0014751e76e8199196d454941c45d1b3a323f1433bd6 Litecoin 2 LaMT348PWRnrqeeWArpwQPbuanpXDZGEUz 76a914a5f4d12ce3685781b227c1f39548ddef429e978388ac MQMcJhpWHYVeQArcZR3sBgyPZxxRtnH441 a914b48297bff5dadecc5f36145cec6a5f20d57c8f9b87 ltc1qdp7p2rpx4a2f80h7a4crvppczgg4egmv5c78w8 0014687c150c26af5493befeed7036043812115ca36c Dogecoin 3 DBXu2kgc3xtvCUWFcxFE3r9hEYgmuaaCyD 76a9144620b70031f0e9437e374a2100934fba4911046088ac AF8ekvSf6eiSBRspJjnfzK6d1EM6pnPq3G a914f8f5d99a9fc21aa676e74d15e7b8134557615bda87 Monacoin 22 MHxgS2XMXjeJ4if2PRRbWYcdwZPWfdwaDT 76a9146e5bb7226a337fe8307b4192ae5c3fab9fa9edf588ac Ethereum 60 0x314159265dD8dbb310642f98f50C066173C1259b 314159265dd8dbb310642f98f50c066173c1259b Rootstock 137 0x5aaEB6053f3e94c9b9a09f33669435E7ef1bEAeD 5aaeb6053f3e94c9b9a09f33669435e7ef1beaed Ripple 144 rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn 004b4e9c06f24296074f7bc48f92a97916c6dc5ea9 X7qvLs7gSnNoKvZzNWUT2e8st17QPY64PPe7zriLNuJszeg 05444b4e9c06f24296074f7bc48f92a97916c6dc5ea9000000000000000000 Bitcoin Cash 145 1BpEi6DfDAUFd7GtittLSdBeYJvcoaVggu 76a91476a04053bda0a88bda5177b86a15c3b29f55987388ac bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a 76a91476a04053bda0a88bda5177b86a15c3b29f55987388ac 3CWFddi6m4ndiGyKqzYvsFYagqDLPVMTzC a91476a04053bda0a88bda5177b86a15c3b29f55987387 bitcoincash:ppm2qsznhks23z7629mms6s4cwef74vcwvn0h829pq a91476a04053bda0a88bda5177b86a15c3b29f55987387 Binance 714 bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 40c2979694bbc961023d1d27be6fc4d21a9febe6 Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-10-wildcard-resolution.html":{"url":"ens-improvement-proposals/ensip-10-wildcard-resolution.html","title":"ENSIP-10: Wildcard Resolution","summary":"Provides a mechanism to support wildcard resolution of ENS names (formerly EIP-2544).","keywords":"","body":"ENSIP-10: Wildcard Resolution Author Nick Johnson \\nick@ens.domains, 0age (@0age) Status Draft Submitted 2020-02-28 Abstract The Ethereum Name Service Specification (ENSIP-1) establishes a two-step name resolution process. First, an ENS client performs the namehash algorithm on the name to determine the associated \"node\", and supplies that node to the ENS Registry contract to determine the resolver. Then, if a resolver has been set on the Registry, the client supplies that same node to the resolver contract, which will return the associated address or other record. As currently specified, this process terminates if a resolver is not set on the ENS Registry for a given node. This ENSIP changes the name resolution process by adding an additional step if a resolver is not set for a domain. This step strips out the leftmost label from the name, derives the node of the new fragment, and supplies that node to the ENS Registry. If a resolver is located for that node, the client supplies the original, complete node to that resolver contract to derive the relevant records. This step is repeated until a node with a resolver is found. Further, this specification defines a new way for resolvers to resolve names, using a unified resolve() method that permits more flexible handling of name resolution. Motivation Many applications such as wallet providers, exchanges, and dapps have expressed a desire to issue ENS names for their users via custom subdomains on a shared parent domain. However, the cost of doing so is currently prohibitive for large user bases, as a distinct record must be set on the ENS Registry for each subdomain. Furthermore, users cannot immediately utilize these subdomains upon account creation, as the transaction to assign a resolver for the node of the subdomain must first be submitted and mined on-chain. This adds unnecessary friction when onboarding new users, who coincidentally would often benefit greatly from the usability improvements afforded by an ENS name. Enabling wildcard support allows for the design of more advanced resolvers that deterministically generate addresses and other records for unassigned subdomains. The generated addresses could map to counterfactual contract deployment addresses (i.e. CREATE2 addresses), to designated \"fallback\" addresses, or other schemes. Additionally, individual resolvers would still be assignable to any given subdomain, which would supersede the wildcard resolution using the parent resolver. Another critical motivation with this standard is to enable wildcard resolution in a backwards-compatible fashion. It does not require modifying the current ENS Registry contract or any existing resolvers, and continues to support existing ENS records — legacy ENS clients would simply fail to resolve wildcard records. Specification The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Let: namehash be the algorithm defined in ENSIP-1. dnsencode be the process for encoding DNS names specified in section 3.1 of RFC1035, with the exception that there is no limit on the total length of the encoded name. The empty string is encoded identically to the name '.', as a single 0-octet. parent be a function that removes the first label from a name (eg, parent('foo.eth') = 'eth'). parent('tld') is defined as the empty string ''. ens is the ENS registry contract for the current network. ENSIP-10-compliant ENS resolvers MAY implement the following function interface: interface ExtendedResolver { function resolve(bytes calldata name, bytes calldata data) external view returns(bytes); } If a resolver implements this function, it MUST return true when supportsInterface() is called on it with the interface's ID, 0x9061b923. ENS clients will call resolve with the DNS-encoded name to resolve and the encoded calldata for a resolver function (as specified in ENSIP-1 and elsewhere); the function MUST either return valid return data for that function, or revert if it is not supported. ENSIP-10-compliant ENS clients MUST perform the following procedure when determining the resolver for a given name: Set currentname = name Set resolver = ens.resolver(namehash(currentname)) If resolver is not the zero address, halt and return resolver. If currentname is the empty name ('' or '.'), halt and return null. Otherwise, set currentname = parent(currentname) and go to 2. If the procedure above returns null, name resolution MUST terminate unsuccessfully. Otherwise, ENSIP-10-compliant ENS clients MUST perform the following procedure when resolving a record: Set calldata to the ABI-encoded call data for the resolution function required - for example, the ABI encoding of addr(namehash(name)) when resolving the addr record. Set supportsENSIP10 = resolver.supportsInterface('0x9061b923'). If supportsENSIP10 is true, set result = resolver.resolve(dnsencode(name), calldata) If supportsENSIP10 is false and name == currentname, set result to the result of calling resolver with calldata. If neither 3 nor 4 are true, terminate unsuccessfully. Return result after decoding it using the return data ABI of the corresponding resolution function (eg, for addr(), ABI-decode the result of resolver.resolve() as an address). Note that in all cases the resolution function (addr() etc) and the resolve function are supplied the original name, not the currentname found in the first stage of resolution. Also note that when wildcard resolution is in use (eg, name != currentname), clients MUST NOT call legacy methods such as addr to resolve the name. These methods may only be called on resolvers set on an exact match for name. Pseudocode function getResolver(name) { for(let currentname = name; currentname !== ''; currentname = parent(currentname)) { const node = namehash(currentname); const resolver = ens.resolver(node); if(resolver != '0x0000000000000000000000000000000000000000') { return [resolver, currentname]; } } return [null, '']; } function resolve(name, func, ...args) { const [resolver, resolverName] = getResolver(name); if(resolver === null) { return null; } const supportsENSIP10 = resolver.supportsInterface('0x9061b923'); if(supportsENSIP10) { const calldata = resolver[func].encodeFunctionCall(namehash(name), ...args); const result = resolver.resolve(dnsencode(name), calldata); return resolver[func].decodeReturnData(result); } else if(name == resolverName) { return resolver[func](...args); } else { return null; } } Rationale The proposed implementation supports wildcard resolution in a manner that minimizes the impact to existing systems. It also reuses existing algorithms and procedures to the greatest possible extent, thereby easing the burden placed on authors and maintainers of various ENS clients. It also recognizes an existing consensus concerning the desirability of wildcard resolution for ENS, enabling more widespread adoption of the original specification by solving for a key scalability obstacle. While introducing an optional resolve function for resolvers, taking the unhashed name and calldata for a resolution function increases implementation complexity, it provides a means for resolvers to obtain plaintext labels and act accordingly, which enables many wildcard-related use-cases that would otherwise not be possible - for example, a wildcard resolver could resolve id.nifty.eth to the owner of the NFT with id id in some collection. With only namehashes to work with, this is not possible. The DNS wire format is used for encoding names as it permits quick and gas-efficient hashing of names, as well as other common operations such as fetching or removing individual labels; in contrast, dot-separated names require iterating over every character in the name to find the delimiter. Backwards Compatibility Existing ENS clients that are compliant with ENSIP-1 will fail to resolve wildcard records and refuse to interact with them, while those compliant with ENSIP-10 will continue to correctly resolve, or reject, existing ENS records. Resolvers wishing to implement the new resolve function for non-wildcard use-cases (eg, where the resolver is set directly on the name being resolved) should consider what to return to legacy clients that call the individual resolution functions for maximum compatibility. Requiring clients to avoid calling existing resolution functions (eg, addr etc) on wildcard resolvers prevents inadvertant backwards compatiability issues with resolvers that answer queries for all names. Security Considerations While compliant ENS clients will continue to refuse to resolve records without a resolver, there is still the risk that an improperly-configured client will refer to an incorrect resolver, or will not reject interactions with the null address when a resolver cannot be located. Additionally, resolvers supporting completely arbitrary wildcard subdomain resolution will increase the likelihood of funds being sent to unintended recipients as a result of typos. Applications that implement such resolvers should consider making additional name validation available to clients depending on the context, or implementing features that support recoverability of funds. There is also the possibility that some applications might require that no resolver be set for certain subdomains. For this to be problematic, the parent domain would need to successfully resolve the given subdomain node — to the knowledge of the authors, no application currently supports this feature or expects that subdomains should not resolve to a record. Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-11-evmchain-address-resolution.html":{"url":"ens-improvement-proposals/ensip-11-evmchain-address-resolution.html","title":"ENSIP-11: EVM compatible Chain Address Resolution","summary":"Introduces coinType for EVM compatible chains (amending ENSIP9).","keywords":"","body":"ENSIP-11: EVM compatible Chain Address Resolution Author Makoto Inoue \\makoto@ens.domains Status Draft Submitted 2022-01-13 Abstract This ENSIP extends ENSIP 9 (multichain address resolution), dedicates a range of coin types for EVM compatible chains, and specifies a way to derive EVM chain IDs to the designated coin types. The dedicated range uses over 0x80000000 (2147483648) which is reserved under ENSIP 9 so there will be no possibility of coin type collision with other non EVM coin types to be added in future. However, some of coin types previously allocated to EVM chain ides will be deprecated. Motivation The existing ENSIP 9 relies on the existence of coin types on SLIP44 which was designed to define address encoding type for deterministic wallets. As the majority of EVM compatible chains inherit the same encoding type as Ethereum, it is redundant to keep requesting the addition of EVM compatible chains into SLIP 44. This specification standardises a way to derive coinType based on Chain ID. Specification This specification amends ENSIP 9 to specify that coin types with the most-significant bit set are to be treated as EVM chain IDs. The MSB is reserved in SLIP44 for other purposes relating to HD wallet key derivation, so no coin types exist in this range. To compute the new coin type for EVM chains, bitwise-OR the chain ID with 0x80000000: 0x80000000 | chainId. export const convertEVMChainIdToCoinType = (chainId: number) =>{ return (0x80000000 | chainId) >>> 0 } And to reverse the operation, bitwise-AND the cointType with 0x7fffffff: 0x7fffffff & coinType. export const convertCoinTypeToEVMChainId = (coinType: number) =>{ return (0x7fffffff & coinType) >> 0 } Implementation An implementation of this interface is provided in the ensdomains/address-encoder repository. Example To compute the new coin type for EVM chains, call convertEVMChainIdToCoinType(chainId) const encoder = require('@ensdomains/address-encoder') > encoder.convertEVMChainIdToCoinType(61) 2147483709 > encoder.convertCoinTypeToEVMChainId(2147483709) 61 You can also use existing functions formatsByName and formatsByCoinType to derive these chain IDs > encoder.formatsByName['XDAI'] { coinType: 2147483748, decoder: [Function (anonymous)], encoder: [Function (anonymous)], name: 'XDAI' } > encoder.formatsByCoinType[2147483748] { coinType: 2147483748, decoder: [Function (anonymous)], encoder: [Function (anonymous)], name: 'XDAI' } Exceptions The following EVM chains are the exception to this standard. AVAX = AVAX has multiple chain address formats, and only c chain is EVM compatible RSK = RSK has its own additional validation They will continue using coinType defined at SLIP44 Backwards Compatibility The following EVM compatible cointypes existed before introducing this new standard. NRG POA TT CELO CLO TOMO EWT THETA GO FTM XDAI ETC When you display them for backward compatibility purposes, append _LEGACY to the cointype and make them read only. Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-improvement-proposals/ensip-12-avatar-text-records.html":{"url":"ens-improvement-proposals/ensip-12-avatar-text-records.html","title":"ENSIP-12: Avatar Text Records","summary":"A standard for storage of the avatar text record in ENS.","keywords":"","body":"ENSIP-12: Avatar Text Records Author Nick Johnson \\nick@ens.domains, Makoto Inoue \\makoto@ens.domains Status Draft Submitted 2022-01-18 Abstract This ENSIP defines a process for retrieving avatar URIs from ENS, several URI schemes for the ENS 'avatar' text field, and how they should be interpreted by clients wishing to display a user's avatar image. Motivation ENS primary name (formerly known as reverse record) has been widely integrated as a de facto web3 user name across many Ethereum based applications. As multiple apps started specifying avatar profile image as well as let users pick NFT as pfp (profile image), it became obvious to store such information within ENS so that the avatar information can be shared across different applications. This specification standardises a way to store and retrieve this information using ENSIP-5: Avatar Text Records Specification Retrieving the avatar URI The process for retrieving the avatar URI depends on whether the client has an Ethereum address or an ENS name to start with. ENS Name To determine the avatar URI for an ENS name, the client MUST first look up the resolver for the name and call .text(namehash(name), 'avatar') on it to retrieve the avatar URI for the name. The client MUST treat the absence of a resolver, an revert when calling the addr method on the resolver, or an empty string returned by the resolver identically, as a failure to find a valid avatar URI. Ethereum Address To determine the avatar URI for an Ethereum address, the client MUST reverse-resolve the address by querying the ENS registry for the resolver of .addr.reverse, where is the lowercase hex-encoded Ethereum address, without leading '0x'. Then, the client calls .text(namehash('.addr.reverse'), 'avatar') to retrieve the avatar URI for the address. If a resolver is returned for the reverse record, but calling text causes a revert or returns an empty string, the client MUST call .name(namehash('.addr.reverse')). If this method returns a valid ENS name, the client MUST: Validate that the reverse record is valid, by resolving the returned name and calling addr on the resolver, checking it matches the original Ethereum address. Perform the process described under 'ENS Name' to look for a valid avatar URI on the name. A failure at any step of this process MUST be treated by the client identically as a failure to find a valid avatar URI. General Format The 'avatar' text field MUST be formatted as a URI. Clients MUST ignore URI types they do not recognise, treating them the same as if no value was set for the field. Image Types Clients MUST support images with mime types of image/jpeg, image/png, and image/svg+xml. Clients MAY support additional image types. URI Types All clients SHOULD support the URI schemes defined below. They MAY implement additional schemes not defined in this specification. https If an https URI is provided, it MUST resolve to an avatar image directly. https URLs MUST NOT resolve to HTML pages, metadata, or other content containing the avatar image. ipfs If an ipfs URI is provided, it MUST resolve to an avatar image directly. Clients without built-in IPFS support MAY rewrite the URI to an https URL referencing an IPFS gateway as described in this document before resolving it as an https URL. data If a data URL is provided, it MUST resolve to an avatar image directly. NFTs A reference to an NFT may be used as an avatar URI, following the standards defined in CAIP-22 and CAIP-29. Clients MUST support at least ERC721 and ERC1155 type NFTs, and MAY support additional types of NFT. To resolve an NFT URI, a client follows this process: Retrieve the metadata URI for the token specified in the avatar field URI. Resolve the metadata URI, fetching the ERC721 or ERC1155 metadata. Extract the image URL specified in the NFT metadata. Resolve the image URL and use it as the avatar. Clients MUST support at least https and ipfs URIs for resolving the metadata URI and the avatar image, and MAY support additional schemes. Clients MAY implement ifps scheme support by rewriting the URI to an HTTPS URL referencing an IPFS gateway as described above. Clients SHOULD additionally take the following verification steps: Where the avatar URI was retrieved via forward resolution (starting from an ENS name), call the addr function on the same resolver and for the same name to retrieve the Ethereum address to which the name resolves. Otherwise, if the avatar URI was retrieved via reverse resolution (starting from an Ethereum address), use that address. Verify that the address from step 1 is an owner of the NFT specified in the URI. If it is not, the client MUST treat the URI as invalid and behave in the same manner as they would if no avatar URI was specified. Clients MAY support NFT URIs by rewriting them to https URIs for a service that provides NFT avatar image resolution support. Examples The following examples all resolve to the same avatar image: eip155:1/erc721:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d/0 # BAYC token 0 ipfs://QmRRPWG96cmgTn2qSzjwr2qvfNEuhunv6FNeMFGa9bx6mQ # IPFS hash for BAYC token 0 image https://ipfs.io/ipfs/QmRRPWG96cmgTn2qSzjwr2qvfNEuhunv6FNeMFGa9bx6mQ # HTTPS URL to IPFS gateway for BAYC token 0 image Backwards Compatibility Not applicable. Security Considerations None. Copyright Copyright and related rights waived via CC0. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"dapp-developer-guide/ens-enabling-your-dapp.html":{"url":"dapp-developer-guide/ens-enabling-your-dapp.html","title":"ENS Enabling your DApp","keywords":"","body":"ENS Enabling your DApp ENS integration in an application encompasses several critical features, each of which can be implemented independently. While comprehensive ENS integration is ideal, even basic support can be a huge benefit to users. Below, we outline three levels of ENS integration. Level 1 is easily achieved and provides high impact for users, while levels 2 and 3 provide more functionality to your users, improving your dApp's usability and your users' experience interacting with your DApp. 1. Resolving ENS names The first step to supporting ENS in your application is making your application understand ENS names, and accepting them anywhere an address is accepted. To understand how to do this, see Resolving Names. If possible, when a user enters an ENS name instead of an address, remember the ENS name, not the address it currently resolves to. This makes it possible for users to update their ENS names and have applications they used the name in automatically resolve to the new address, in the same way that you would expect your browser to automatically direct you to the new IP address if a site you use changes servers. If your application deals with user funds or other critical resources, you may want to keep track of the address a name resolves to and warn them when it changes, to ensure they are aware of the change. By accepting ENS names in your application, you remove the need for users to copy and paste - or worse, type out - long and opaque Ethereum addresses, which leads to errors and lost funds. 2. Support Reverse Resolution The second level of ENS integration involves displaying ENS names wherever your app currently displays addresses. If a user entered an ENS in your DApp, you should retain this name and show it to them whenever you would normally show the address. If a user entered an address, or the address was obtained from elsewhere, you may still be able to show an ENS name, by doing Reverse Resolution. This permits you to find the canonical name for an address and display that when possible. If no canonical name is provided, your application can fall back to displaying the address as it did previously. By supporting reverse resolution, you make it easier for your users to identify accounts they interact with, associating them with a short human-readable name instead of a long opaque Ethereum address. 3. Let Users Name Things The final step for comprehensive ENS integration is to facilitate associating ENS names with resources created by or managed with your application. This can take two forms: Name Registration By obtaining an ENS name for your product and allowing users to easily register subdomains, you can provide users with an easy way to name resources created in your DApp. For example, if your DApp is a cryptocurrency wallet, you can make it easy for users to obtain an ENS domain of the form theirname.yourwallet.eth, allowing them to give their name out to others more easily. To learn how to do this, see Writing a Registrar in the Smart Contract Developer Guide. Name Updates By providing users with an easy way to update a name they own to point at your application’s resources, users can assign names they already own to your DApp's resources. See Managing Names to learn how to do this. Tell Us About Your Integration If you've ENS Enabled your app, let us know by emailing nick@ens.domains; we'll add your app to our homepage. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"dapp-developer-guide/ens-libraries.html":{"url":"dapp-developer-guide/ens-libraries.html","title":"ENS Libraries","keywords":"","body":"ENS Libraries ENS support is available in many popular languages. If you know of a library that is not listed here, please send us a PR. Javascript ensjs, maintained by the ENS developers ethereum-ens (deprecated) react-ens-address ethers.js web3.js embark.io waffle.io Which Javascript library should I use? If you are already using web3.js or ethers.js, and do not require functionality such as creating subdomains, transferring ownership, or updating resolvers, use built in ENS features of these libraries. If you are using React and only need to do forward and reverse resolution of ENS names with built in UI, use react-ens-address. If you want to have ENS instance deployed into your dev environment, you may want to use embark.io or waffle.io which allows you to configure/deploy ENS registry in your Ethereum test instance. Otherwise, use ensjs. Accessing smart contracts directly All the ENS smart contracts are published as @ensdomains/ens-contracts npm module. This is how you include abi into your frontend code. import { ENS, PublicResolver } from '@ensdomains/ens-contracts'` This is how you import our smartcontract within Solidity. import '@ensdomains/ens-contracts/contracts/registry/ENS.sol'; Java web3j Kotlin KEthereum Python web3.py - also see web3.py ENS docs Go go-ens Command-line ethereal Delphi delphereum Next Steps Once you've chosen a library, read Working with ENS to learn how to use your chosen ENS library in your application. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"dapp-developer-guide/working-with-ens.html":{"url":"dapp-developer-guide/working-with-ens.html","title":"Working with ENS","keywords":"","body":"Working with ENS Before you can begin interacting with ENS, you will need to obtain a reference to the ENS registry. How you do this depends on the library you are using. Example code for the Javascript-based APIs (ensjs, web3.js, ethjs-ens, and ethers.js) here expect that they are being run inside a DApp browser, such as Chrome with metamask installed, which exposes the ethereum object. import ENS, { getEnsAddress } from '@ensdomains/ensjs' const ens = new ENS({ provider, ensAddress: getEnsAddress('1') }) var Web3 = require(\"web3\") var accounts = ethereum.enable(); var web3 = new Web3(ethereum); var ens = web3.eth.ens; const ENS = require('ethjs-ens'); // Currently requires both provider and // either a network or registryAddress param var accounts = ethereum.enable(); const ens = new ENS({ ethereum, network: '1' }); var ethers = require('ethers'); var provider = new ethers.providers.Web3Provider(ethereum); // ENS functionality is provided directly on the core provider object. import ( ens \"github.com/wealdtech/go-ens/v2\" ethereum \"github.com/ethereum/go-ethereum\" ) // Can dial up a connection through either IPC or HTTP/HTTPS client, err := ethereum.Dial(\"/home/ethereum/.ethereum/geth.ipc\") registry, err := ens.Registry(client) from ens.auto import ns EnsResolver ens = new EnsResolver(web3j, 300 /* sync threshold, seconds */); Some web3 libraries - e.g., ethers.js, web3j, and web3.py - have integrated support for name resolution. In these libraries, you can pass in an ENS name anywhere you can supply an address, meaning you do not need to interact directly with their ENS APIs unless you want to manually resolve names or do other ENS operations. If no library is available for your platform, you can instantiate the ENS registry contract directly using the interface definition here. Addresses for the ENS registry on each supported network are available in the ENS Deployments page. &a all right reserved，powered by GitbookUpdated at 2022-05-18 18:36:50 "},"dapp-developer-guide/resolving-names.html":{"url":"dapp-developer-guide/resolving-names.html","title":"Resolving Names","keywords":"","body":"Resolving Names The ENS namespace includes both .eth names (which are native to ENS) and DNS names imported into ENS. Because the DNS suffix namespace expands over time, a hardcoded list of name suffixes for recognizing ENS names will regularly be out of date, leading to your application not recognizing all valid ENS names. To remain future-proof, a correct integration of ENS treats any dot-separated name as a potential ENS name and will attempt a look-up. Looking up cryptocurrency addresses Names can have many types of data associated with them; the most common is cryptocurrency addresses. ENS supports storing and resolving the addresses of any arbitrary blockchain. Resolving a name to an Ethereum address using a library is simple: Resolution without a library is a three step process: Normalise and hash the name - see name processing for details. Call resolver() on the ENS registry, passing in the output of step 1. This returns the address of the resolver responsible for the name. Using the resolver interface, call addr() on the resolver address returned in step 2, passing in the hashed name calculated in step 1. Resolution support for the addresses of other blockchains is implemented with an additional overload on addr(). To resolve a non-Ethereum address, supply both the namehash and the SLIP44 chain ID of the cryptocurrency whose address you want to resolve. For example, to resolve a Bitcoin address, you would call addr(hash, 0). Note that the returned address will be in binary representation, and so will need decoding to a text-format address; for details, see EIP 2304. If you are resolving addr() records, you MUST treat a return value from the resolver of 0x00…00 as that record being unset. Failing to do so could result in users accidentally sending funds to the null address if they have configured a resolver in ENS, but not set the resolver record! Looking up other resources ENS supports many types of resources besides Ethereum addresses, including other cryptocurrency addresses, content hashes (hashes for IPFS, Skynet, and Swarm, and Tor .onion addresses), contract interfaces (ABIs), and text-based metadata. The process for looking these up varies from library to library; for specific details see your chosen library's documentation. Resolving these content types without a library follows the same 3-step process detailed above; simply call the relevant method on the resolver in step 3 instead of addr(). // Getting contenthash await ens.name('abittooawesome.eth').getContent() // Setting contenthash await ens.name('abittooawesome.eth').setContenthash(contentHash) // Getting other coins await ens.name('brantly.eth').getAddress('BTC') // Setting other coins await ens.name('superawesome.eth').setAddress('ETC', '0x0000000000000000000000000000000000012345') // Getting text await ens.name('resolver.eth').getText('url') // Setting text await ens.name('superawesome.eth').setText('url', 'http://google.com') // Getting contenthash web3.eth.ens.getContenthash('ethereum.eth').then(function (result) { console.log(result); }); // Setting contenthash web3.eth.ens.setContenthash('ethereum.eth', hash); Not supported. const resolver = await provider.getResolver('abittooawesome.eth'); const contentHash = await resolver.getContentHash(); const btcAddress = await resolver.getAddress(0); const dogeAddress = await resolver.getAddress(3); const email = await resolver.getText(\"email\"); // Encoding bin, err := ens.StringToContenthash(\"/ipfs/QmayQq2DWCkY3d4x3xKh4suohuRPEXe2fBqMBam5xtDj3t\") // Setting contenthash resolver.SetContenthash(opts, data) // Getting contenthash resolver.Contenthash() // Decoding repr, err := ens.ContenthashToString(bin) // Getting Multicoin btcAddress, err := resolver.MultiAddress(0) // Setting Multicoin resolver.SetMultiAddress(opts, address) // Setting text resolver.SetText(opts, name, value) // Getting text resolver.Text(name) Not supported. Not supported. Encoding and decoding contenthash contenthash is used to store IPFSand Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks. content-hash javascript library provides a convenient way to encode/decode these hashes. const contentHash = require('content-hash') const encoded = 'e3010170122029f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1f' const content = contentHash.decode(encoded) // 'QmRAQB6YaCyidP37UdDnjFY5vQuiBrcqdyoW1CuDgwxkD4' const onion = 'zqktlwi4fecvo6ri' contentHash.encode('onion', onion); // 'bc037a716b746c776934666563766f367269' const encoded = 'e40101701b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162' const codec = contentHash.getCodec(encoded) // 'swarm-ns' codec === 'ipfs-ns' // false Note for ipns: For security reasons, the encoding of ipns is only allowed for libp2p-key codec. Decoding with other formats will show a deprecation warning. Please read here for more detail. Coin type and encoding/decoding While some libraries allow you to query cryptocurrency addresses via their symbol (e.g.: BTC), others do not have the built-in support, and you have to call via each coin id (e.g.: 0 for BTC, 16 for `ETH). For Javascript/Typescript, we have @ensdomains/address-encoder library that allows you to convert import { formatsByName, formatsByCoinType } from '@ensdomains/address-encoder'; formatsByName['BTC'] // { // coinType: 0, // decoder: [Function (anonymous)], // encoder: [Function (anonymous)], // name: 'BTC' // } To save storage space as well as prevent users from setting wrong token address, the library has encoder and decoder const data = formatsByName['BTC'].decoder('1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa'); console.log(data.toString('hex')); // 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac const addr = formatsByCoinType[0].encoder(data); console.log(addr); // 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa Listing cryptocurrency addresses and text records For cryptocurrency addresses and text records, you need to know the coin type or key names to get the value. If you want to list down all the cryptocurrency addresses and text records the user has set, you have to either retrieve the information from Event or query via ENS subgraph. For example { domains(where:{name:\"vitalik.eth\"}) { id name resolver{ texts coinTypes } } } will return the following result { \"data\": { \"domains\": [ { \"id\": \"0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835\", \"name\": \"vitalik.eth\", \"resolver\": { \"coinTypes\": [ 60 ], \"texts\": [ \"url\" ] } } ] } } Reverse Resolution While 'regular' resolution involves mapping from a name to an address, reverse resolution maps from an address back to a name. ENS supports reverse resolution to allow applications to display ENS names in place of hexadecimal addresses. Reverse resolution is accomplished via the special purpose domain addr.reverse and the resolver function name(). addr.reverse is owned by a special purpose registrar contract that allocates subdomains to the owner of the matching address - for instance, the address 0x314159265dd8dbb310642f98f50c066173c1259b may claim the name 314159265dd8dbb310642f98f50c066173c1259b.addr.reverse, and configure a resolver and records on it. The resolver in turn supports the name() function, which returns the name associated with that address. ENS does not enforce the accuracy of reverse records - for instance, anyone may claim that the name for their address is 'alice.eth'. To be certain that the claim is accurate, you must always perform a forward resolution for the returned name and check it matches the original address. Most libraries provide functionality for doing reverse resolution: const address = '0x1234...'; let ensName = null; ({ name: ensName } = await ens.getName(address)) // Check to be sure the reverse record is correct. skip check if the name is null if(ensName == null || address != await ens.name(ensName).getAddress()) { ensName = null; } Not supported. var address = '0x1234...'; var name = await ens.reverse(address); // Check to be sure the reverse record is correct. if(address != await ens.lookup(name)) { name = null; } var address = '0x1234...'; var name = await provider.lookupAddress(address); // ethers.js automatically checks that the forward resolution matches. name, err := ens.ReverseResolve(client, common.HexToAddress(\"0x1234...\") address = '0x1234...' name = ns.reverse(address) # Check to be sure the reverse record is correct. if address != ns.address(name): name = None String address = \"0x1234...\"; String name = ens.reverseResolve(address); // Check to be sure the reverse record is correct. if(address != ens.resolve(name)) { name = null; } Reverse resolution without a library follows the same pattern as forward resolution: Get the resolver for 1234....addr.reverse(where 1234... is the address you want to reverse-resolve), and call the name() function on that resolver. Then, perform a forward resolution to verify the record is accurate. If you need to process many addresses (eg: showing reverse record of transaction histories), resolving both reverse and forward resolution for each item may not be practical. We have a seperate smart contract called ReverseRecords which allows you to lookup multiple names in one function call. const namehash = require('eth-ens-namehash'); const allnames = await ReverseRecords.getNames(['0x123','0x124']) const validNames = allnames.filter((n) => namehash.normalize(n) === n ) Make sure to compare that the returned names match with the normalised names to prevent from homograph attack as well as people simply using capital letters. &a all right reserved，powered by GitbookUpdated at 2022-05-18 18:38:51 "},"dapp-developer-guide/managing-names.html":{"url":"dapp-developer-guide/managing-names.html","title":"Managing Names","keywords":"","body":"Managing Names Transferring a Name Each name in ENS has an owner. This account or contract is the only one that may make changes to the name in the ENS registry. The owner of a name can transfer ownership to any other account. await ens.name('alice.eth').setOwner('0x1234...'); // opts are go-ethereum's bind.TransactOpts err := registry.SetOwner(opts, \"alice.eth\", common.HexToAddress(\"0x1234...\")) ns.setup_owner('alice.eth', '0x1234...') Creating Subdomains The owner of any domain can configure subdomains as desired. This is achieved by creating a subdomain and setting its owner to the desired address - this can be the same as the owner of the parent domain, or any other address. await ens.name('alice.eth').createSubdomain('iam'); // opts are go-ethereum's bind.TransactOpts err := registry.SetSubdomainOwner(opts, \"alice.eth\", \"iam\", common.HexToAddress(\"0x1234...\")) ns.setup_owner('iam.alice.eth', '0x1234...') Additionally, web3.py provides a convenience method to create a subdomain, set a resolver, and configure an address record all at once: ns.setup_address('iam.alice.eth', '0x1234...') In the common case that the name should be pointed to the owner's address, the second argument is optional. Setting a Resolver Before a newly created domain or subdomain can be used, a resolver address must be set. You may also want to do this if an updated resolver implementation is available that supports features that you want to make use of. Most commonly, names are set to use a 'standard' resolver called the public resolver, which provides commonly-used functionality, but anyone may write and deploy their own special-purpose resolver; see the resolver interface definition for details. await ens.name('iam.alice.eth').setResolver('0x1234'); On mainnet and the Kovan test network, 'resolver.eth' is configured to point to the latest deployed version of the public resolver, making it possible to easily configure a name to use the public resolver: const resolver = await ens.resolver('resolver.eth').addr(); await ens.setResolver('iam.alice.eth', resolver, {from: ...}); // opts are go-ethereum's bind.TransactOpts err := registry.SetResolver(opts, \"iam.alice.eth\", common.HexToAddress(\"0x1234...\")) Not supported. web3.py automatically uses the public resolver when setup_address is called, and does not support setting custom resolvers. Note that changing the resolver for a name will not automatically migrate records from the old resolver over; to do this you will need to follow the process outlined below for updating records. Updating Records To change the resources an address resolves to, it's necessary to update that name's records in its resolver. Each resolver may specify its own mechanism for updating records, but a standard method is implemented by the public resolver and many others. Some libraries provide functionality for updating a resolver's records using this interface. Updating the Address Record await ens.name('iam.alice.eth').setAddr('ETH', '0x1234...'); resolver, err := ens.NewResolver(client, \"iam.alice.eth\") // opts are go-ethereum's bind.TransactOpts err := resolver.SetAddress(opts, common.HexToAddress(\"0x1234...\")) ens.setAddress('iam.alice.eth, '0x1234...', {from: ...}); ns.setup_address('iam.alice.eth', '0x1234...') Updating Other Records Some libraries - presently only ensjs, go-ens and web3.js - support updating other record types, such as content hashes and text records, using the same pattern. For example, to set or update a text record: ens.name('iam.alice.eth').setText('test', 'Test record'); // opts are go-ethereum's bind.TransactOpts err := resolver.SetContenthash(opts, []byte{0x12, 0x34...}) err := resolver.SetAbi(opts, \"Sample\", `[{\"constant\":true,\"inputs\":...}]`, big.NewInt(1)) err := resolver.SetText(opts, \"Sample\", `Hello, world`) ens.setText('iam.alice.eth', 'Test', 'Test record', {from: ...}); Updating multiple records in one transaction Public Resolver has multicall that permits users to set multiple records in a single operation. Read PublicResolver section for more detail. Configuring Reverse Resolution While 'regular' resolution involves mapping from a name to an address, reverse resolution maps from an address back to a name - or other metadata. ENS supports reverse resolution to allow applications to display ENS names in place of hexadecimal addresses. Before this can be done, the owner of the address has to configure reverse resolution for their address. This is done by calling the claim() method on the reverse resolver, found at the special name 'addr.reverse'. Most commonly this is accomplished via a user-interface such as the ENS Manager DApp. go-ens and web3.py also provide functionality for this: reverseRegistrar, err := ens.NewReverseRegistrar(client) // opts are go-ethereum's bind.TransactOpts err := reverseRegistrar.SetName(opts, \"iam.alice.eth\") ns.setup_name('iam.alice.eth', '0x1234...') &a all right reserved，powered by GitbookUpdated at 2022-05-18 18:39:46 "},"dapp-developer-guide/registering-and-renewing-names.html":{"url":"dapp-developer-guide/registering-and-renewing-names.html","title":"Registering & Renewing Names","keywords":"","body":"Registering & Renewing Names When users want to obtain a domain for the first time, they must interact with a registrar. Registrars are smart contracts that own a domain, and have a defined process for handing out subdomains. The registrar a user needs to interact with depends on the domain they want to obtain; for instance, a user wanting a .eth name will have to interact with the .eth registrar. Each registrar defines its own API for name registrations (and renewals, where appropriate). At present, there are no libraries for interacting with registrars; DApps wishing to do so must interact with the registrar contract using a generic Ethereum library such as web3.js or web3.py. See the Contract API Reference for details on each registrar's interface. Deployed Registrars .eth: The Permanent Registrar. .test (testnets only): The test registrar. .addr.reverse: The reverse registrar. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"dapp-developer-guide/front-end-design-guidelines.html":{"url":"dapp-developer-guide/front-end-design-guidelines.html","title":"ENS Front-End Design Guidelines","summary":"ENS is a tool to simplify the experience for your users. Here are a series of guidelines and tools that will help you make design choices and implement the best ENS user experience.","keywords":"","body":"ENS Front-End Design Guidelines When to show ENS names In every instance a user might otherwise see an Ethereum address or content hash, you can instead display an ENS name.There are two primary use cases for allowing users to display ENS names in your dapp: Replacing Ethereum addresses with ENS names: When users are exploring the front-end of your dapp, wherever you would display an Ethereum address, you can instead display an ENS name. Resolving input fields: You can allow the user to write an ENS name in an input field that expects an Ethereum address, rather than entering the Ethereum address. Beyond these use cases, remember that the ENS Public Resolver allows you to link different kinds of resources, such as content stored on IPFS or Swarm, or any arbitrary data like text fields, to ENS names. This means there are other situations in which you might want to use ENS in your dapp. For example, if you are using complicated IPFS or Swarm hashes it is possible to convert the hashes to human readable names using ENS. Learn more about the different use cases in the chapter about Enabling ENS in your DApp. 1. Replacing Ethereum Addresses with ENS Names An ENS name (as a substitute for an Ethereum Address) should only be shown if the user has set a Reverse Record for their address, and if the reverse record (address > name) matches the forward resolution (name > address). As a dApp developer you should therefore first check if the Reverse Record for a given address has been set by the user, and, because users can set the reverse record to be anything they want, even a name they don't own or a random string, you should immediately after check that the resolved name also resolves to the same address by performing the forward resolution. Read more here and in the 'other guidelines' section further down. 1.1 - Displaying ENS names instead of Ethereum addresses When replacing Ethereum addresses with ENS names you should consider these facts and best practices: Consider adding a visual checksum: it is important to indicate to the user that a name is an ENS name that relates to an Ethereum address or other hash, rather than an http link. To do this, it is advisable to associate the ENS name with some form of visual checksum: identicons, Blockies or other custom algorithmic representation of the address. Visual checksums like identicons can be spoofed or imitated. Therefore they are not meant as a security mechanism. They are only meant as an indicator, to let the user understand that the name is just a different representation of an Ethereum Address. Design a truncated version of the ENS name: ENS names can be very long; besides not being character-limited, users can create an infinite number of subdomains and subdomains of subdomains. If you do show a truncated version of the name, you should provide a way to view the full name, such as expanding it on hover. Not all ENS names end with .eth: ENS names normally end with .eth. However other top-level domains (TLD) are currently supported (.xyz, .luxe, .kred, .art, .club) and more will be in the future. Consider this if you are thinking about displaying the TLD part in the truncated view of long names. 1.2 - Always provide an option to see the Ethereum address associated with the ENS name If you are showing the ENS name in its entirety or a truncated version, you should: Always provide the user a way to display the full Ethereum address: The above example illustrates a pop-up option. Another option would be to use a tooltip. However, consider that floating / pop-ups may be more appropriate than tooltips because the former also supports the other features described here. Provide a view where you display both the ENS name and the Ethereum address together: If the pop-up hides the name and only shows the address it's less friendly than showing both at the same time. Allow the user to copy the full Ethereum address: Allow the user to copy the full address either through a copy button or by selecting it. Tooltips displaying the ENS name in this case should stay visible and not automatically disappear. Optionally give the user a way to automatically open the Ethereum address in a block explorer such as Etherscan (the external link icon in the above example). Optionally show the balance amount, but only to the current signed-in user. User research shows that users tend to recognise their own Ethereum address through their balance, as well as the address itself. This is meant only for the currently \"signed in\" user: only show their own balance and avoid showing the balance of other users. 1.3 - Displaying ENS names and Ethereum addresses together In some situations you might want to display both the ENS name and the Ethereum address to which it resolves. These layouts can be useful when: Displaying the currently connected user: For the user badge, for example, it could be appropriate to display both the ENS name and a short version of the Ethereum address. The user inputs an ENS name into an input field: This will be described in greater detail in the next chapter that discusses input field resolution. In other high-risk situations: These are situations where the user wants to confirm who a given user/address is, or if you notice that your users keep clicking ENS names because they want to see the Ethereum address in the pop-up, then you could substitute the simple version (only the ENS name) with one that displays both the name and the address. 2. Resolving Input Fields Input fields where a user is supposed to insert Ethereum addresses should also accept and resolve ENS names. These inputs indicate that the user wants to interact with another user's Ethereum address or contract. Follow these guidelines to create the best experience: Wait before resolving the ENS name: Wait until the user has typed the last TLD, e.g. .eth, .xyz, .luxe or .kred before resolving the name. Alternatively wait until 0.2 - 1.0 seconds after the user has stopped typing in the input field (avoid the eager resolution problem). Don't overwrite the input field with the Ethereum address: Show the resolved ENS name near the input field instead. Always display both the ENS name and the Ethereum address together : Do this after it has successfully been resolved and possibly add also a visual checksum following the suggestions in guideline 1.1. Other guidelines and tips What to do if the Reverse Record doesn't correspond to the Forward Resolution? As mentioned before, user can set the Reverse Record to be anything they want, even a name owned by another user or a completely random string. This is why, after retrieving the name written in the Reverse Record, a dApp developer should also check that it matches the forward resolution, which means the address that ENS name points to.If the two don't match, you MUST NOT show the human readable name and simply leave the plain Ethereum Address. If you don't, users may be able to impersonate other users in your dApp.The chapter on Reverse Resolution has code for you to do this check. Options for displaying usernames The obvious choice is to use the user's ENS name as a username. You can do this by providing a mechanism for your users to register a name under your own subdomain, or by looking up the user's ENS name using reverse resolution. Caching and Updating ENS Names If your dApp needs to display many Ethereum Addresses or ENS Names in the UI, you can also consider caching the ENS Name after it has been resolved (and verified) or after the user has added the name in an input field. Your optimistic UI can safely display the names from cache in all non-risky situations, in which your user for example is simply browsing, but doesn't need to act or make decisions, especially risky ones, based on the information displayed.However, in all risky situations (eg transferring ETH, tokens or other value), or when the user is interacting with another ENS Name / Ethereum Address, you should perform a direct live resolution and get the most up to date information from the ENS Registry. Also consider that users can change their information in the ENS registry at any time so you should periodically validate the information you cached. For this you can also subscribe to certain Events made available by the contracts (especially AddrChanged, and NameChanged). **** Notes on displaying Ethereum Addresses (with or without ENS names) Even when ENS names are not available, research shows that there are some good practices to follow when displaying Ethereum addresses in dApps. Always show the initial ' 0x ' to indicate it's an address. When displaying the name in shorthand versions, show the first 4 and last 4 characters of the address. This is not a security requirement as vanity addresses can be spoofed relatively simply; this is a good practice because some users check the beginning of the name and others check the end of the name. Also, four is the highest number of elements that our mind can easily chunk, parse and remember well. Always provide a way to display the full Ethereum address. Use the same pop-up component that you would use to display ENS names or a tooltip style. Other guidelines previously mentioned also apply for simple Ethereum addresses: Allow the user to copy the full Ethereum address (which mean that tooltips might not be good practice). (Optionally) allow the user to automatically open the address in a block explorer. Front-End tools Aragon-UI - Address Badge component (Design Files / code) Decentraland-UI - address Tooltip (not ENS specific) &a all right reserved，powered by GitbookUpdated at 2022-05-18 18:40:23 "},"dapp-developer-guide/ens-as-nft.html":{"url":"dapp-developer-guide/ens-as-nft.html","title":"ENS as NFT","keywords":"","body":"ENS as NFT When ENS .eth registrar migrated in May 2019, the .eth registrar became an ERC721 compliant non-fungible token contract, meaning that .eth registrations can be transferred in the same fashion as other NFTs. Deriving tokenId from ENS name The tokenId of ENS name is simply the uint256 representation of the hash of the label (vitalik for vitalik.eth). const ethers = require('ethers') const BigNumber = ethers.BigNumber const utils = ethers.utils const name = 'vitalik' const labelHash = utils.keccak256(utils.toUtf8Bytes('vitalik')) const tokenId = BigNumber.from(labelHash).toString() In the example above,79233663829379634837589865448569342784712482819484549289560981379859480642508 is the tokenId of vitalik.eth Deriving ENS name from tokenId Unlike deriving tokenId, deriving ENS name from tokenId is not as easy. This is because all ENS names are stored as fixed-length hash to allow registering infinite length of names. The downside of this architecture is that you cannot directly query ENS smart contracts to return ENS name using tokenId. Our recommended way is to query via https://thegraph.com ENS subgraph. The graph decodes the hash to name as it indexes. The example code to query is as follows. const ethers = require('ethers') const BigNumber = ethers.BigNumber const gr = require('graphql-request') const { request, gql } = gr const tokenId = '79233663829379634837589865448569342784712482819484549289560981379859480642508' // Should return 0xaf2caa1c2ca1d027f1ac823b529d0a67cd144264b2789fa2ea4d63a67c7103cc const labelHash = BigNumber.from(tokenId).toHexString() const url = 'https://api.thegraph.com/subgraphs/name/ensdomains/ens' const GET_LABEL_NAME = gql` query{ domains(first:1, where:{labelhash:\"${labelHash}\"}){ labelName } }` request(url, GET_LABEL_NAME).then((data) => console.log(data)) // { domains: [ { labelName: 'vitalik' } ] } If you prefer not to rely on a third party like TheGraph, the team open-sourced ens-rainbow containing a link to the original dataset (6GB with 133 million entities) so that you can host your own ENS name decoding service. Turning subdomain into NFT Currently, all the subdomains nor non .eth domains are not NFT, unless the domain registrar itself supports NFT such as (dcl.eth, and .kred). If you want to turn all subdomains which you own, you have to create a registrar Create a registrar contract as ERC721 compliant Set ENS registry address (mostly when you deploy the registrar) Create register function which calls registry.setSubnodeOwner then mint the token making the subdomain label hash as tokenId contract DCLRegistrar is ERC721Full, Ownable { constructor( IENSRegistry _registry, ) public ERC721Full(\"DCL Registrar\", \"DCLENS\") { // ENS registry updateRegistry(_registry); } function register( string memory _subdomain, bytes32 subdomainLabelHash, address _beneficiary, uint256 _createdDate ) internal { // Create new subdomain and assign the _beneficiary as the owner registry.setSubnodeOwner(domainNameHash, subdomainLabelHash, _beneficiary); // Mint an ERC721 token with the subdomain label hash as its id _mint(_beneficiary, uint256(subdomainLabelHash)); } } Once deployed, then you have to transfer the controller address to the contract. For non-technical users, we are currently working on upgrading our SubdomainRegistrar which allows you to turn your subdomain into NFT without any coding. Metadata .eth does not have .tokenURI . However, we created a separate metadata service which NFT marketplaces like OpenSea can fetch metadata for ENS such as registration data, expiration date, name length, etc. For more detail, please refer to the metadata documentation site. &a all right reserved，powered by GitbookUpdated at 2022-05-18 18:40:50 "},"dapp-developer-guide/ens-l2-offchain.html":{"url":"dapp-developer-guide/ens-l2-offchain.html","title":"ENS Layer2 and offchain data support","keywords":"","body":"ENS Layer2 and offchain data support Summary With the proliferation of layer 2 solutions for Ethereum that are starting to reach maturity, it's important that ENS is able to provide resolution services across the entire ecosystem, as well as making it possible for ENS users to take advantage of the efficiencies made possible by Layer 2 solutions. Subsequent to a post by Vitalik that suggested a possible means for this, the ENS team and the wider ENS and L2 community have been working on a general-purpose \"Layer 2 bridge\" that makes cross-platform interoperability possible for both ENS and other applications that need to be able to retrieve data from a variety of offchain sources (any data that resides outside of Ethereum Mainnet also known as layer 1/L1. This includes both propriety database and layer 2/L2 solutions such as Optimism, Arbitrum, Starkware, ZKSync, and so on) in a trustless fashion and came up with standards. EIP-3668: CCIP Read: Secure offchain data retrieval ENSIP 10: Wildcard Resolution EIP 3668 allows for offchain (including Layer 2/L2) lookups of data in a way that is transparent to clients and provides contract authors to implement whatever validation is necessary; in many cases, this can be provided without any additional trust assumptions over and above those required if data is stored onchain. ENSIP 10 is a general way to resolve wildcard (eg: *.foo.eth) on L1. Issuing subdomains and moving the resolution of the parent name offchain allows dapps to create subdomains offchain yet make it accessible through L1. Steps required for Dapps and wallets to support offchain data lookup. If your dapps or wallets use one of those libraries, the EIP 3668 and ENSIP 10 support will be built in, so simply update the library when ready. ethersjs web3js ethersjs 5.6.1 supports both EIP3668 and ENSIP 10. No code change is required as long as your app is interacting with ENS through etherjs ENS methods. To try out these features, offchainexample.eth points to so-called \"offchain resolver\" that fetches data from JSON configuration file hosted on google app engine. It will reply data to any record for offchainexample.eth and its subdomain record such as 2.offchainexample.eth. The example resolver is not using L2 data but the same mechanism works when the L2 resolver becomes ready. const { ethers } = require(\"ethers\"); const url = `https://mainnet.infura.io/v3/${process.env.API_KEY}` const provider = new ethers.providers.JsonRpcProvider(url); async function main(){ let resolver = await provider.getResolver('1.offchainexample.eth') let address = await provider.resolveName('1.offchainexample.eth') let email = await resolver.getText('email') console.log({resolver:resolver.address, address, email}) } main() The expected output is as follows. $node index.js { resolver: '0xC1735677a60884ABbCF72295E88d47764BeDa282', address: '0x41563129cDbbD0c5D3e1c86cf9563926b243834d', email: 'nick@ens.domains' } @chainlink/ethers-ccip-read-provider(source) also implements EIP 3668 as an independent npm module The basic usage example is as follows. import { CCIPReadProvider } from '@chainlink/ethers-ccip-read-provider'; import { abi as IExtendedResolver_abi } from '@ensdomains/offchain-resolver-contracts/artifacts/contracts/IExtendedResolver.sol/IExtendedResolver.json'; const IExtendedResolver = new ethers.utils.Interface(IExtendedResolver_abi); const baseProvider = ethers.getDefaultProvider(options.provider); const provider = new CCIPReadProvider(baseProvider); Please refer to offchain resolver client example code for more detail. web3js Work in progress Any other libraries If you use other libraries or custom integration, please raise the GitHub issue to the project repo or at ENS project management repo if the equivalent repo does not exist so that ENS team can keep track of the progress. Steps required for Dapps and wallets to issue subdomains offchain If you wish to issue subdomains using offchain data storage, please follow offchain resolver as a reference point. The example uses a flat file as a data source but can easily be replaced with database calls. L2 support is still a work in progress. FAQ Is the change backwards compatible? Yes. The existing names on L1 will continue working without clients nor applications supporting these standards. Only names that are outside of L1 will not be resolved. Will L2/offchain data be supported by GraphQL? Once each L2 is officially supported, we will need to spin up a subgraph for each L2 bridge, and we will use schema stitching to make using them transparent to callers. For names that are not hosted on a supported L2, we won't be able to fetch data that are normally only available on the subgraph How do you support other EVM compatible chains? Non-L2 chains lack ways to verify data on L1 in the trustless manner. The alternative is for chain bridge operators to act as a trusted third-party and hosts the offchain gateway, or individual dapps hosts own gateway and sign each data with the private key of the ENS name. Can I issue a new tld unique to an offchain environment? No. Please read \"Why ENS Doesn't Create More TLDs: Responsible Citizenship in the Global Namespace\" for more detail Can I set a primary name to names on offchain? Yes, you can. However, reverse registrar (it is a hidden top-level domain starting with .addr.reverse) currently resides on L1; hence you have to pay gas on L1. We may consider moving the reverse registrar to L2 in future. Can I register .eth name on offchain? Only when we migrate .eth name to a specific L2 as one of the last steps of our migration after finding out which L2 supports ENS integration the best. How do I handle contract addresses? Unlike EOA (Externally Owned Account), contract based accounts such as multisig may only be accessible in certain chains. ENSIP-11 allows a single name to hold different addresses across multiple EVM compatible chains and recommendation is to store contract addresses to EVM chain specific address record field. Can I use libraries from other name services that support .eth? @unstoppabledomains/resolution removed ENS support as of December 2021. Other services tend not to support all ENS TLDs especially DNS based TLDs (.com, .net, etc) so we advise not to rely on these libraries resolving ENS names. References and previous discussions MVP of ENS on L2 with Optimism: Demo Video + How to Try It Yourself A general-purpose bridge for Ethereum Layer 2s A general-purpose L2-friendly ENS standard Video: ENS Workshop on 18th Oct 2021 Video: ENS Workshop on 6th April 2021 Video: ENS on Layer 2 meeting #2 on 28th Oct 2020 Video: ENS on Layer 2 meeting on 13th Oct 2020 Video: ENS workshop on 29th Sep 2020 &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"contract-api-reference/name-processing.html":{"url":"contract-api-reference/name-processing.html","title":"Name Processing","summary":"Describes how to normalize and hash ENS names.","keywords":"","body":"Name Processing In place of human-readable names, ENS works purely with fixed length 256-bit cryptographic hashes. In order to derive the hash from a name while still preserving its hierarchal properties, a process called Namehash is used. For example, the namehash of 'alice.eth' is 0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec; this is the representation of names that is used exclusively inside ENS. Before being hashed with namehash, names are first normalized, using a process called UTS-46 normalization. This ensures that upper- and lower-case names are treated equivalently, and that invalid characters are prohibited. Anything that hashes and resolves a name must first normalize it, to ensure that all users get a consistent view of ENS. Normalising Names Before a name can be converted to a node hash using Namehash, the name must first be normalized and checked for validity - for instance, converting fOO.eth into foo.eth, and prohibiting names containing forbidden characters such as underscores. It is crucial that all applications follow the same set of rules for normalization and validation, as otherwise two users entering the same name on different systems may resolve the same human-readable name into two different ENS names. Applications using ENS and processing human-readable names must follow UTS46 for normalization and validation. Processing should be done with non-transitional rules, and with UseSTD3ASCIIRules=true. The eth-ens-namehash Javascript library performs both normalization and hashing as described here. All of the ENS libraries covered in the DApp Developer Guide also perform normalization and hashing. Hashing Names Namehash is a recursive process that can generate a unique hash for any valid domain name. Starting with the namehash of any domain - for example, 'alice.eth' - it's possible to derive the namehash of any subdomain - for example 'iam.alice.eth' - without having to know or handle the original human-readable name. It is this property that makes it possible for ENS to provide a hierarchal system, without having to deal with human-readable text strings internally. Terminology domain - The complete, human-readable form of a name; eg, iam.alice.eth. label - A single component of a domain - eg, iam, alice, or eth. label hash - the output of the keccak-256 function applied to a label; eg, keccak256(‘eth’) = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0 node - The output of the namehash function, used to uniquely identify a name in ENS. Algorithm First, a domain is divided into labels by splitting on periods (‘.’). So, ‘vitalik.wallet.eth’ becomes the list [‘vitalik’, ‘wallet’, ‘eth’]. The namehash function is then defined recursively as follows: namehash([]) = 0x0000000000000000000000000000000000000000000000000000000000000000 namehash([label, …]) = keccak256(namehash(…), keccak256(label)) A sample implementation in Python is provided below. def namehash(name): if name == '': return '\\0' * 32 else: label, _, remainder = name.partition('.') return sha3(namehash(remainder) + sha3(label)) Namehash is specified in EIP 137. How do I find the labelhash/namehash of a name? In some cases, you may need to know the hash of the name stored in ENS. labelhash means hash of the label of the domain (eg: makoto for makoto.eth) and namehash is the hash which combines labelhashes. We are currently working to include this information in our Manager app. In the meantime, you can query the information via https://thegraph.com/explorer/subgraph/ensdomains/ens with the following query. { domains(where: {name:\"vitalik.eth\"}) { id name labelName labelhash } } Handling of Ambiguous Names Because of the large number of characters in unicode, and the wide variety of scripts represented, inevitably there are different Unicode characters that are similar or even identical when shown in common fonts. This can be abused to trick users into thinking they are visiting one site or resource, when in fact they are visiting another. This is known as a homoglyph attack. User agents and other software that display names to users should take countermeasures against these attacks, such as by highlighting problematic characters, or showing warnings to users about mixed scripts. Chromium’s IDNA strategy may serve as a useful reference for user-agent behaviour around rendering IDNA names. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"contract-api-reference/ens.html":{"url":"contract-api-reference/ens.html","title":"Registry","summary":"The ENS registry.","keywords":"","body":"Registry Source The ENS registry is the core contract that lies at the heart of ENS resolution. All ENS lookups start by querying the registry. The registry maintains a list of domains, recording the owner, resolver, and TTL for each, and allows the owner of a domain to make changes to that data. The ENS registry is specified in EIP 137. Get Owner function owner(bytes32 node) external view returns (address); Returns the owner of the name specified by node. Get Resolver function resolver(bytes32 node) external view returns (address); Returns the address of the resolver responsible for the name specified by node. Get TTL function ttl(bytes32 node) external view returns (uint64); Returns the caching time-to-live of the name specified by node. Systems that wish to cache information about a name, including ownership, resolver address, and records, should respect this value. If TTL is zero, new data should be fetched on each query. Set Owner function setOwner(bytes32 node, address owner) external; Reassigns ownership of the name identified by node to owner. Only callable by the current owner of the name. Emits the following event: event Transfer(bytes32 indexed node, address owner); Set Resolver function setResolver(bytes32 node, address resolver) external; Updates the resolver associated with the name identified by node to resolver. Only callable by the current owner of the name. resolver must specify the address of a contract that implements the Resolver interface. Emits the following event: event NewResolver(bytes32 indexed node, address resolver); Set TTL function setTTL(bytes32 node, uint64 ttl) external; Updates the caching time-to-live of the name identified by node. Only callable by the current owner of the name. Emits the following event: event NewTTL(bytes32 indexed node, uint64 ttl); Set Subdomain Owner function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external; Creates a new subdomain of node, assigning ownership of it to the specified owner. If the domain already exists, ownership is reassigned but the resolver and TTL are left unmodified. label is the keccak256 hash of the subdomain label to create. For example, if you own alice.eth and want to create the subdomain iam.alice.eth, supply namehash('alice.eth') as the node, and keccak256('iam') as the label. Emits the following event: event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner); Set Record function setRecord(bytes32 node, address owner, address resolver, uint64 ttl); Sets the owner, resolver, and TTL for an ENS record in a single operation. This function is offered for convenience, and is exactly equivalent to calling setResolver, setTTL and setOwner in that order. Set Subdomain Record function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl); Sets the owner, resolver and TTL for a subdomain, creating it if necessary. This function is offered for convenience, and permits setting all three fields without first transferring ownership of the subdomain to the caller. Set Approval function setApprovalForAll(address operator, bool approved); Sets or clears an approval. Approved accounts can execute all ENS registry operations on behalf of the caller. Check Approval function isApprovedForAll(address owner, address operator) external view returns (bool); Returns true if operator is approved to make ENS registry operations on behalf of owner. Check Record Existence function recordExists(bytes32 node) public view returns (bool); Returns true if node exists in this ENS registry. This will return false for records that are in the legacy ENS registry but have not yet been migrated to the new one. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"contract-api-reference/reverseregistrar.html":{"url":"contract-api-reference/reverseregistrar.html","title":"ReverseRegistrar","summary":"The registrar responsible for managing reverse resolution via the .addr.reverse special-purpose TLD.","keywords":"","body":"ReverseRegistrar Source Reverse resolution in ENS - the process of mapping from an Ethereum address (eg, 0x1234...) to an ENS name - is handled using a special namespace, .addr.reverse. A special-purpose registrar controls this namespace and allocates subdomains to any caller based on their address. For example, the account 0x314159265dd8dbb310642f98f50c066173c1259b can claim 314159265dd8dbb310642f98f50c066173c1259b.addr.reverse. After doing so, it can configure a resolver and expose metadata, such as a canonical ENS name for this address. The reverse registrar provides functions to claim a reverse record, as well as a convenience function to configure the record as it's most commonly used, as a way of specifying a canonical name for an address. The reverse registrar is specified in EIP 181. Claim Address function claim(address owner) public returns (bytes32); Claims the caller's address in the reverse registrar, assigning ownership of the reverse record to owner. Equivalent to calling claimWithResolver(owner, 0). Claim Address with Resolver function claimWithResolver(address owner, address resolver) public returns (bytes32) Claims the caller's address in the reverse registrar, assigning ownership of the reverse record to owner. If resolver is nonzero, also updates the record's resolver. After calling this function: The reverse record for the caller (1234....addr.reverse) is owned by owner. If resolver is nonzero, the reverse record for the caller has its resolver set to resolver; otherwise it is left unchanged. Set Name function setName(string memory name) public returns (bytes32) Configures the caller's reverse ENS record to point to the provided name. This convenience function streamlines the process of setting up a reverse record for the common case where a user only wants to configure a reverse name and nothing else. It performs the following steps: Sets the reverse record for the caller to be owned by the ReverseRegistrar. Sets the reverse record for the caller to have defaultResolver as its resolver. Sets the name() field in the defaultResolver for the caller's reverse record to name. In short, after calling this, a user has a fully configured reverse record claiming the provided name as that account's canonical name. Users wanting more flexibility will need to use claim or claimWithResolver and configure records manually on their chosen resolver contract. Get Reverse Record Node function node(address addr) public pure returns (bytes32) Accepts an address, and returns the node (namehash output) for the address's reverse record. This function is provided as a convenience for contracts wishing to look up metadata for an address, and avoids the need for those contracts to handle the hex encoding and hashing necessary to derive the required value. Get Default Resolver Resolver public defaultResolver; Returns the address of the resolver contract that the ReverseRegistrar uses for setName. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"contract-api-reference/testregistrar.html":{"url":"contract-api-reference/testregistrar.html","title":"TestRegistrar","keywords":"","body":"TestRegistrar Source The Test registrar facilitates easy testing of ENS on the Ethereum test networks. Typically deployed on the .test TLD, it provides functionality to instantly claim a domain for test purposes, which expires 28 days after it was claimed. Register a Domain function register(bytes32 label, address owner) public; Registers the subdomain whose keccak256 hash is provided in label, and assigns ownership to owner. For example, to register myname.test, call register with keccak256('myname') as the first argument. Registrations after 28 days. Get expiration time mapping (bytes32 => uint) public expiryTimes; Returns the unix timestamp at which the specified subdomain will expire. For example, to check the expiration time of myname.test, call expiryTimes(keccak256('myname')). &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"contract-api-reference/publicresolver.html":{"url":"contract-api-reference/publicresolver.html","title":"PublicResolver","summary":"The default public resolver.","keywords":"","body":"PublicResolver Source PublicResolver implements a general-purpose ENS resolver that is suitable for most standard ENS use-cases. The public resolver permits updates to ENS records by the owner of the corresponding name. The public resolver implements the following EIPs: EIP 137 - Contract address interface (addr()). EIP 165 - Interface Detection (supportsInterface()). EIP 181 - Reverse resolution (name()). EIP 205 - ABI support (ABI()). EIP 619 - SECP256k1 public keys (pubkey()). EIP 634 - Text records (text()). EIP 1577 - Content hash support (contenthash()). EIP 2304 - Multicoin support (addr()). While the PublicResolverprovides a convenient default implementation, many resolver implementations and versions exist. Callers must not assume that a domain uses the current version of the public resolver, or that all of the methods described here are present. To check if a resolver supports a feature, see Check Interface Support. Check Interface Support function supportsInterface(bytes4 interfaceID) external pure returns (bool) ENS uses ERC 165 for interface detection. ERC 165 requires that supporting contracts implement a function, supportsInterface, which takes an interface ID and returns a boolean value indicating if this interface is supported or not. Interface IDs are calculated as the exclusive-or of the four-byte function identifiers of each function included in the interface. For example, addr(bytes32) has the function ID 0x3b3b57de. Because it is the only function in the Ethereum Address interface, its interface ID is also 0x3b3b57de, and so calling supportsInterface(0x3b3b57de) will return true for any resolver that supports addr(). ERC 165 has an interface ID of 0x01ffc9a7, so supportsInterface(0x01ffc9a7) will always return true for any ERC 165 supporting contract (and hence for any resolver). Note that the public resolver does not expose explicit interfaces for setter functions, so there are no automated means to check for support for a given setter function. Get Ethereum Address function addr(bytes32 node) external view returns (address) Returns the Ethereum address associated with the provided node, or 0 if none. This function has interface ID 0x3b3b57de. This function is specified in EIP 137. Set Ethereum Address function setAddr(bytes32 node, address addr) external; Sets the Ethereum address associated with the provided node to addr. Only callable by the owner of node. Emits the following event: event AddrChanged(bytes32 indexed node, address a); Get Blockchain Address function addr(bytes32 node, uint coinType) external view returns(bytes memory); Returns the Blockchain address associated with the provided node and coinType, or 0 if none. This function has interface ID 0xf1cb7e06. This function is specified in EIP 2304. The return value is the cryptocurrency address in its native binary format and each blockchain address has a different encoding and decoding method. For example, the Bitcoin address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa base58check decodes to the 21 bytes 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18 then scriptPubkey encodes to 25 bytes 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac whereas the BNB address bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 Bech32 decodes to the binary representation 40c2979694bbc961023d1d27be6fc4d21a9febe6. To convert the binary representation into the address, use formatsByCoinType[SYMBOL].encoder(binary) of address-encoder. A zero-length string will be returned if the specified coin ID does not exist on the specified node. Set Blockchain Address function setAddr(bytes32 node, uint coinType, bytes calldata a) external; Sets the blockchain address associated with the provided node and coinType to addr. coinType is the cryptocurrency coin type index from SLIP44. To convert the address into the binary representation, use formatsByName[SYMBOL].decoder(text) of address-encoder Only callable by the owner of node. Emits the following event: event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress); Get Canonical Name function name(bytes32 node) external view returns (string memory); Returns the canonical ENS name associated with the provided node. Used exclusively for reverse resolution. This function has interface ID 0x691f3431. This function is specified in EIP 181. Set Canonical Name function setName(bytes32 node, string calldata name) external; Sets the canonical ENS name for the provided node to name. Only callable by the owner of node. Emits the following event: event NameChanged(bytes32 indexed node, string name); Get Content Hash function contenthash(bytes32 node) external view returns (bytes memory); Returns the content hash for node, if one exists. Values are formatted as machine-readable multicodecs, as specified in EIP 1577. contenthash is used to store IPFS and Swarm content hashes, which permit resolving ENS addresses to distributed content (eg, websites) hosted on these distributed networks. This function has interface ID 0xbc1c58d1. This function is specified in EIP 1577. Set Content Hash function setContenthash(bytes32 node, bytes calldata hash) external; Sets the content hash for the provided node to hash. Only callable by the owner of node. Values are formatted as machine-readable multicodecs, as specified in EIP 1577. Emits the following event: event ContenthashChanged(bytes32 indexed node, bytes hash); Get Contract ABI ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory); Returns a matching ABI definition for the provided node, if one exists. contentTypes is the bitwise-OR of the encodings that the caller can accept. If multiple content types are specified, the resolver will select one to return. Currently supported content types are: Content Type ID Description 1 JSON 2 zlib-compressed JSON 4 CBOR 8 URI ABI returns a two-tuple of the content type ID and the ABI data. If no data of the appropriate content type ID was found, 0 is returned for the content type ID, and the ABI data will be the empty string. This function has interface ID 0x2203ab56. This function is specified in EIP 205. Set Contract ABI function setABI(bytes32 node, uint256 contentType, bytes calldata data) external Sets or updates ABI data for node. contentType specifies the content type ID (see Get Contract ABI for valid values); exactly one type ID must be specified. data contains the encoded ABI data. To clear ABI data for a name, specify the empty string for data. Only callable by the owner of node. Emits the following event: event ABIChanged(bytes32 indexed node, uint256 indexed contentType); Get Public Key function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) Returns the ECDSA SECP256k1 public key for node, as a 2-tuple (x, y). If no public key is set, (0, 0) is returned. This function has interface ID 0xc8690233. This function is specified in EIP 619. Set Public Key function setPubkey(bytes32 node, bytes32 x, bytes32 y) external Sets the ECDSA SECP256k1 public key for node to (x, y). Only callable by the owner of node. Emits the following event: event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y); Get Text Data function text(bytes32 node, string calldata key) external view returns (string memory) Retrieves text metadata for node. Each name may have multiple pieces of metadata, identified by a unique string key. If no text data exists for node with the key key, the empty string is returned. Standard values for key are: key Meaning email An email address url A URL avatar A URL to an image used as an avatar or logo description A description of the name notice A notice regarding this name keywords A list of comma-separated keywords, ordered by most significant first; clients that interpresent this field may choose a threshold beyond which to ignore In addition, anyone may specify vendor-specific keys, which must be prefixed with vnd.. The following vendor-specific keys are currently known: key Meaning com.twitter Twitter handle com.github Github username This function has interface ID 0x59d1d43c. This function is specified in EIP 634. Set Text Data function setText(bytes32 node, string calldata key, string calldata value) external Sets text metadata for node with the unique key key to value, overwriting anything previously stored for node and key. To clear a text field, set it to the empty string. Only callable by the owner of node. Emits the following event: event TextChanged(bytes32 indexed node, string indexedKey, string key); Multicall function multicall(bytes[] calldata data) external returns(bytes[] memory results) Permits users to set multiple records in a single operation. Use encodeABI function to encode your contract calls and pass it to data. The frontend usage will be as follows: var addrSet = resolver.contract.methods['setAddr(bytes32,address)'](node, accounts[1]).encodeABI(); var textSet = resolver.contract.methods.setText(node, \"url\", \"https://ethereum.org/\").encodeABI(); var tx = await resolver.multicall([addrSet, textSet], {from: accounts[0]}); &a all right reserved，powered by GitbookUpdated at 2022-05-18 18:41:28 "},"contract-api-reference/.eth-permanent-registrar/":{"url":"contract-api-reference/.eth-permanent-registrar/","title":".eth Permanent Registrar","keywords":"","body":".eth Permanent Registrar The Permanent Registrar is the code that will govern allocation and renewal of names in the .eth TLD. System architecture Code for the permanent registrar can be found in the ethregistrar repository. The registrar itself is called BaseRegistrar. This contract implements several key functions: The owner of the registrar may add and remove 'controllers'. Controllers may register new domains and extend the expiry of (renew) existing domains. They can not change the ownership or reduce the expiration time of existing domains. Name owners may transfer ownership to another address. Name owners may reclaim ownership in the ENS registry if they have lost it. Owners of names in the legacy registrar may transfer them to the new registrar, during the 1 year transition period. When they do so, their deposit is returned to them in its entirety. In addition, the registrar is an ERC721 compliant nonfungable token contract, meaning that .eth registrations can be transferred in the same fashion as other NFTs. Users will interact directly with this contract when transferring ownership of names, or recovering ownership in the ENS registry of a name (for example, one whose ownership was previously transferred to a contract). Users can also query names to see their registration status and expiry date. For initial registration and for renewals, users will need to interact with a controller contract. This separation of concerns reduces the attack surface for the registrar, and provides users with guarantees of continued ownership of a name so long as the registrar is in place. Simultaneously, it provides for improvement and innovation over registration and renewal mechanisms. A future update may transfer ownership of the root and the .eth TLD to a contract with restricted permissions, thus preventing even the root keyholders from modifying a .eth registraion, while still providing for future updates to the set of controllers. Initially, one controller is implemented, the ETHRegistrarController. This controller provides a straightforward registration and renewal mechanism for domains that are 7 or more characters long, implementing the following functionality: The owner of the controller may set a price oracle contract, which determines the cost of registrations and renewals based on the name and the desired registration or renewal duration. The owner of the controller may withdraw any collected funds to their account. Users can register new names using a commit/reveal process and by paying the appropriate registration fee. Users can renew a name by paying the appropriate fee. Any user may renew a domain, not just the name's owner. There is no limit on renewal duration. By allowing anyone to renew a domain, users concerned with the longevity of a name they interact with can ensure it remains registered by paying for the registration themselves, if necessary. By allowing renewal for arbitrarily long periods of time, users can 'lock in' a desirable registration fee. Names can be made effectively 'immortal' by renewing for a long period, ensuring that stability of the name can be guaranteed by smart contract. Initially, a single pricing oracle was deployed, the StablePriceOracle. This contract permits its owner to set prices in USD for each permitted name length, and uses a USD:ETH price oracle to convert those prices into Ether at the current rate. Users will not have to interact with this oracle directly, as the controller provides functionality to determine pricing for a candidate name registration or renewal. Discovery Finding the address of the new registrar is straightforward: look up the owner of the domain 'eth' in ENS, by calling owner(namehash('eth')) on the ENS registry. In order to support discovering the address of the controller, ENS supports interface discovery via EIP 1844. This mechanism permits looking up the address of the contract that implements a required interface via the following process: Set node = namehash('eth'). Look up the ENS resolver by calling resolver(node) on the ENS registry. Call the interfaceImplementer(node, interfaceId) method on that resolver, where interfaceId is the EIP 165 interface ID of the interface you need. The following interface IDs are presently defined for the .eth permanent registrar: 0x6ccb2df4, the interface ID for ERC721 (NFTs). This returns the address of the registrar itself (which can also be fetched by doing an address lookup, or by looking up the owner of '.eth'. 0x018fac06, the interface ID for the controller. Returns the controller's address. 0x7ba18ba1, the interface ID for the legacy registrar's migration function. Returns the legacy registrar's address. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"contract-api-reference/.eth-permanent-registrar/registrar.html":{"url":"contract-api-reference/.eth-permanent-registrar/registrar.html","title":"Registrar","keywords":"","body":"Registrar Source This contract implements the core functionality of the permanent registrar, with the following features: The owner of the registrar may add and remove 'controllers'. Controllers may register new domains and extend the expiry of (renew) existing domains. They can not change the ownership or reduce the expiration time of existing domains. Name owners may transfer ownership to another address. Name owners may reclaim ownership in the ENS registry if they have lost it. Owners of names in the legacy registrar may transfer them to the new registrar, during the 1 year transition period. When they do so, their deposit is returned to them in its entirety. This section documents the parts of the registrar interface relevant to implementers of tools that interact with it. Functionality exclusive to the registrar owner or to controllers is omitted for brevity. The registrar works exclusively with label hashes - the keccak256 of the first component of the label (eg, keccak256('ens') for ens.eth). For compatibility with ERC721, these are expressed as uint256 values rather than bytes32, but can be cast backwards and forwards transparently. The namehash of a name can be derived by computing keccak256(baseNode, labelHash), where basenode is the namehash of the TLD the registrar manages - eg, namehash('eth'). Registrations and renewals are handled via the controller. Names and Registrations All names inside ENS have an owner. The owner of a name can transfer the name to a new owner, set a resolver, and create and reassign subdomains. This functionality is all contained in the ENS registry. Allocation of names directly under .eth (eg, second-level domains ending with .eth, such as alice.eth) is governed by the .eth Permanent Registrar, described here. While buying a name from the registrar grants ownership of it in ENS, the registrar itself keeps independent track of who owns the registration. The concept of a registrant - the owner of a registration - is unique to the .eth permanent registrar. The registrant of a name can transfer the registration to another account, and they can recover ownership of the name by calling reclaim, which resets ownership of the ENS name to the registrant's account. Separating the concept of owning a name from owning a registration makes it possible to more easily build systems that make automated updates to ENS. The registrant can transfer ownership of the name to another account or to a smart contract that manages records, subdomains, etc, while still retaining the ability to recover ownership for upgrades, or in the case of a compromise. When thinking about ownership, it's important to be clear whether you're considering ownership of the name or the registration. Read Operations Get Name Expiry function nameExpires(uint256 label) external view returns(uint); Returns the unix timestamp at which a registration currently expires. Names that do not exist or are not yet migrated from the legacy registrar will return 0. Check Name Availability function available(uint256 label) public view returns(bool); Returns true if a name is available for registration. Takes into account not-yet-migrated registrations from the legacy registrar. Registrar controllers may impose more restrictions on registrations than this contract (for example, a minimum name length), so this function should not be used to check if a name can be registered by a user. To check if a name can be registered by a user, check name availability via the controller. Get Transfer Period End uint public transferPeriodEnds; transferPeriodEnds documents the unix timestamp at which it is no longer possible to migrate over registrations from the legacy registrar, and any non-migrated registrations become available for registration by anyone. Get Controller Status mapping(address=>bool) public controllers; controllers allows callers to check if the supplied address is authorized as a registrar controller. Check Token Approval function getApproved(uint256 tokenId) public view returns (address operator); Returns the address of the approved operator for this name. This function is part of ERC721. Check All Tokens Approval function isApprovedForAll(address owner, address operator) public view returns (bool); Returns true if operator is authorized to transfer all tokens for owner. This function is part of ERC721. Get Name Owner function ownerOf(uint256 label) external view returns(address); ownerOf returns the address that owns the registration identified by the label hash, or reverts if the registration does not exist. Registrations that have not yet been migrated from the legacy registrar are treated the same as registrations that do not exist. This function is part of ERC721. Write Operations Transfer a Name function transferFrom(address from, address to, uint256 tokenId) public; function safeTransferFrom(address from, address to, uint256 tokenId) public; function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public; These functions transfer the registration. They behave as specified in ERC721. Emits the following event on a successful transfer: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); Approve Operator function approve(address to, uint256 tokenId) public; function setApprovalForAll(address operator, bool _approved) public; These functions manage approvals as documented in ERC721. Reclaim ENS Record function reclaim(uint256 label) external; Sets the owner record of the name in the ENS registry to match the owner of the registration in this registry. May only be called by the owner of the registration. Events Name Migrated event NameMigrated(uint256 indexed hash, address indexed owner, uint expires); This event is emitted when a name is migrated from the legacy registrar. Name Registered event NameRegistered(uint256 indexed hash, address indexed owner, uint expires); This event is emitted when a controller registers a new name. Name Renewed event NameRenewed(uint256 indexed hash, uint expires); This event is emitted when a controller renews (extends the registration of) a name. Transfer event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); This event is emitted when registration is transferred to a new owner. This is distinct from the ENS Registry's Transfer event, which records transfers of ownership of the ENS record. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"contract-api-reference/.eth-permanent-registrar/controller.html":{"url":"contract-api-reference/.eth-permanent-registrar/controller.html","title":"Controller","keywords":"","body":"Controller Source This section documents the parts of the ETHRegistrarController relevant to implementers of tools that interact with it. Functionality exclusive to the registrar owner is omitted for brevity. The controller works exclusively with plaintext labels (eg, 'alice' for 'alice.eth'). To prevent frontrunning, the ETHRegistrarController requires a commit/reveal process for new name registrations (but not for renewals). To register a name, the user must: Generate a commitment hash from the name they want to register and a secret value. Submit the commitment hash from #1 to the controller. Wait for at least 1 minute, but no longer than 24 hours. Submit a registration request for the name, along with the secret value from #1. This process ensures that registrations cannot be frontrun unless the attacker is able to censor the user's transactions for at least 1 minute. Examples Name Registration The below example demonstrates the steps required to register a name. const controller = web3.eth.contract(controller_abi).at(controller_address); async function register(name, owner, duration) { // Generate a random value to mask our commitment const random = new Uint8Array(32); crypto.getRandomValues(random); const salt = \"0x\" + Array.from(random).map(b => b.toString(16).padStart(2, \"0\")).join(\"\"); // Submit our commitment to the smart contract const commitment = await controller.makeCommitment(name, owner, salt); const tx = await controller.commit(commitment); // Add 10% to account for price fluctuation; the difference is refunded. const price = (await controller.rentPrice(name, duration)) * 1.1; // Wait 60 seconds before registering setTimeout(async () => { // Submit our registration request await controller.register(name, owner, duration, salt, {value: price}); }, 60000); } For clarity, this example is written using async rather than callbacks. As a result, this example works in web3 1.0.x; note that it will not work in the web3 injected by MetaMask, as this presently is an older version lacking async support. Read Operations Get Minimum Commitment Age uint constant public MIN_COMMITMENT_AGE; This public constant provides the minimum commitment age, in seconds. A commitment can only be revealed after at least this many seconds have passed since it was mined. DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases. Get Maximum Commitment Age uint constant public MAX_COMMITMENT_AGE; This public constant provides the maximum commitment age, in seconds. A commitment that was mined more than this number of seconds ago is no longer valid, and cannot be used to register a name. DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases. Get Minimum Registration Duration uint constant public MIN_REGISTRATION_DURATION; This public constant provides the minimum registration duration, in seconds. Registrations for less than this duration will be rejected. DApps should fetch this constant rather than hardcoding the current value, as it's possible it will change with future releases. Get Commitment Timestamp mapping(bytes32=>uint) public commitments; commitments stores a mapping from each submitted to commitment to the timestamp at which it was made. Callers wishing to validate that a commitment is valid before submitting a registration transaction should check this map first. Get Rent Price function rentPrice(string name, uint duration) view public returns(uint); rentPrice returns the cost, in wei, to register or renew the provided name for the provided duration, in seconds. Callers should note that this price may vary over time, particularly if the pricing oracle is relying on a fiat price conversion. Callers should use this function to obtain registration costs to display to the user rather than calculating them internally, as future changes to the pricing oracle may result in different pricing schemes, with registration cost-per-year depending on name length, registration duration, or other variables. Check Name Validity function valid(string name) public view returns(bool); valid returns true iff name is valid for registration with this controller (eg, it meets length requirements). Check Name Availability function available(string name) public view returns(bool); available returns true iff the name is both valid and available for registration by this controller. Under the hood, this call uses the valid function (above) and the available function on the registrar contract, which checks for availability in both the legacy ENS registrar and current ENS registrar. Callers should use this function to check if a name is available for registration, rather than the available function on the registrar contract, which does not check name length. Calculate Commitment Hash function makeCommitment(string name, address owner, bytes32 secret) pure public returns(bytes32); makeCommitment generates and returns a commitment hash from a name label (eg, 'myname', not 'myname.eth') owner, and secret value. Write Operations Submit Commitment function commit(bytes32 commitment) public; commit submits a precommitment generated by calling makeCommitment. Register Name function register(string name, address owner, uint duration, bytes32 secret) public payable; register registers a name. A valid registration request must meet the following criteria: available(name) == true. duration >= MIN_REGISTRATION_DURATION. secret identifies a valid commitment (eg, commitments[makeCommitment(name, secret)] exists and is between 1 minute and 24 hours old. msg.value >= rentPrice(name, duration). Because the rent price may vary over time, callers are recommended to send slightly more than the value returned by rentPrice - a premium of 5-10% will likely be sufficient. Any excess funds are returned to the caller. Emits the following event on a successful call: event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires); A successful call also results in the Registrar emitting a Name Registered Event, and the ENS registry emitting a New Owner Event. Extend Name Registration function renew(string name, uint duration) external payable; renew renews a name, extending the name's expiration by duration seconds. This function can be called by anyone, as long as sufficient funds are provided. Because the rent price may vary over time, callers are recommended to send slightly more than the value returned by rentPrice - a premium of 5-10% will likely be sufficient. Any excess funds are returned to the caller. Emits the following event on a successful call: event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires); A successful call also results in the Registrar emitting a Name Renewed Event. &a all right reserved，powered by GitbookUpdated at 2022-05-18 18:42:02 "},"contract-api-reference/dns-registrar.html":{"url":"contract-api-reference/dns-registrar.html","title":"DNS Registrar","keywords":"","body":"DNS Registrar At ENS, we have two smart contracts, DNSSECOracle and DNSRegistrar. DNSSEC (The Domain Name System Security Extensions) establishes a chain of trust from the root key which is signed by ICANN (.) and down through each key. We start off knowing the hash of the root key of DNS (this is hard coded in the smart contract oracle). Given the hashes of that key, we can pass in the actual key, we can verify that it matches the hash and we can add it to the set of the trusted records. Given that key, we can now verify any record that is signed with that key, so in this case, it’s the hash of the root of the xyz top-level domain. Given that, we can recognize the key, and so on and so forth. .png>) DNSSEC oracle allows anyone to submit proof of any DNSSEC-signed DNS record on the Ethereum blockchain, as long as it was signed using supported public key schemes and digests. DNSRegistrar grants ENS domains to anyone who can prove ownership of the corresponding domain in DNS through DNSSEC Oracle to prove this. Deployed DNSRegistrar addresses Mainnet, at TBD. Ropsten, at 0x475e527d54b91b0b011DA573C69Ac54B2eC269ea. When you register ENS names, you can look up the registrar contract address by looking up its parent domain owner (eg: .eth, for .matoken.eth). However, when you register via DNSSEC Registrars, the parent domain owner may not exist if you are the first person to register under the TLD. Gas cost Submitting proof to DNSSEC Oracle takes up a lot of gas because it is heavy computation work. It will take up even more gas if you submit the first domain under the specific TLD. This is because it submits proof of both your domain and its parent domain(eg: matoken.live, as well as .live). When tested on Ropsten network, it cost 1,663,953 gas Typescript/Javascript Libraries To help you interact with DNSSEC data and the DNSRegistrar, we provide two libraries. DNSProvejs = A library for querying and validating DNSSEC data from DNS dnssecoraclejs = A library for generating proof data for the ENS DNSSEC Oracle. Examples Retrieving proof from DNS import { Oracle } from '@ensdomains/dnssecoraclejs' import { DNSProver } from '@ensdomains/dnsprovejs' const textDomain = '_ens.matoken.xyz' const prover = DNSProver.create(\"https://cloudflare-dns.com/dns-query\") const result = await prover.queryWithProof('TXT', textDomain) Retrieving the DNS text record const result = { answer: SignedSet { records: [{ name: '_ens.matoken.xyz', type: 'TXT', ttl: 300, class: 'IN', flush: false, data: [Array] }], signature: { name: '_ens.matoken.xyz', type: 'RRSIG', ttl: 300, class: 'IN', flush: false, data: [Object] } }, proofs: [ SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] } ] } // Retrieving the text record result.answer.records[0].data.toString() // 'a=0xa5313060f9fa6b607ac8ca8728a851166c9f612' queryWithProof returns answer and proofs. answer contains the human-readable record of the DNS record and its signing signature (RRSIG). The example above shows that the leaf of the chain (the first returned record) contains the TXT record type in a=$ETHEREUM_ADDRESS format. Submitting the proof to the DNSRegistrar import { Oracle } from '@ensdomains/dnssecoraclejs' import { abi } from '@ensdomains/contracts/abis/dnsregistrar/DNSRegistrar.json' import { Contract } from 'ethers' // The registrar address nees to be hard-coded const registrarAddress = '0x475e527d54b91b0b011DA573C69Ac54B2eC269ea' const registrar new Contract(registrarAddress, abi, provider) const oracleAddress = await registrar.oracle() const oracle = new Oracle(oracleAddress, provider) const { data, proof } = oracle.getProofData(result) if(data.length === 0){ // This happens if someone has submitted the proof directly to DNSSECOracle, hence only claim a name on the registrar. return registrar.claim(claim.encodedName, proof) }else{ // This submits proof to DNSSECOracle, then claim a name. return registrar.proveAndClaim(claim.encodedName, data, proof) } Todo It is currently missing the Typescript/JS library support to delete the record from DNSSECOracle by providing NSEC/NSEC3(Next Secure Record) proof. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"contract-developer-guide/resolving-names-on-chain.html":{"url":"contract-developer-guide/resolving-names-on-chain.html","title":"Resolving Names On-chain","keywords":"","body":"Resolving Names On-chain Solidity libraries for on-chain resolution are not yet available, but ENS resolution is straightforward enough it can be done trivially without a library. First, we define some pared-down interfaces containing only the methods we need: abstract contract ENS { function resolver(bytes32 node) public virtual view returns (Resolver); } abstract contract Resolver { function addr(bytes32 node) public virtual view returns (address); } For resolution, only the resolver function in the ENS contract is required; other methods permit looking up owners and updating ENS from within a contract that owns a name. With these definitions, looking up a name given its node hash is straightforward: contract MyContract { // Same address for Mainet, Ropsten, Rinkerby, Gorli and other networks; ENS ens = ENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e); function resolve(bytes32 node) public view returns(address) { Resolver resolver = ens.resolver(node); return resolver.addr(node); } } While it is possible for a contract to process a human-readable name into a node hash, we highly recommend working with node hashes instead, as they are easier and more efficient to work with, and allow contracts to leave the complex work of normalizing the name to their callers outside the blockchain. Where a contract always resolves the same names, those names may be converted to a node hash and stored in the contract as a constant. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"contract-developer-guide/writing-a-resolver.html":{"url":"contract-developer-guide/writing-a-resolver.html","title":"Writing a Resolver","keywords":"","body":"Writing a Resolver Resolvers are specified in EIP137. A resolver must implement the following method: function supportsInterface(bytes4 interfaceID) constant returns (bool); supportsInterface is defined in EIP165, and allows callers to determine if a resolver supports a particular record type. Record types are specified as a set of one or more methods that a resolver must implement together. Currently defined record types include: Record type Function(s) Interface ID Defined in Ethereum address addr 0x3b3b57de EIP137 ENS Name name 0x691f3431 EIP181 ABI specification ABI 0x2203ab56 EIP205 Public key pubkey 0xc8690233 EIP619 Text records text 0x59d1d43c EIP634 Content hash contenthash 0xbc1c58d1 supportsInterface must also return true for the interfaceID value 0x01ffc9a7, which is the interface ID of supportsInterface itself. Additionally, the content interface was used as a defacto standard for Swarm hashes, and has an interface ID of 0xd8389dc5. New implementations should use contenthash instead. Example Resolver A simple resolver that supports only the addr type might look something like this: contract SimpleResolver { function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de; } function addr(bytes32 nodeID) constant returns (address) { return address(this); } } This trivial resolver always returns its own address as answer to all queries. Practical resolvers may use any mechanism they wish to determine what results to return, though they should be constant, and should minimise gas usage wherever possible. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"contract-developer-guide/writing-a-registrar.html":{"url":"contract-developer-guide/writing-a-registrar.html","title":"Writing a Registrar","keywords":"","body":"Writing a Registrar A registrar in ENS is simply any contract that owns a name, and allocates subdomains of it according to some set of rules defined in the contract code. A trivial first in first served contract is demonstrated below: contract FIFSRegistrar { ENS ens; bytes32 rootNode; function FIFSRegistrar(address ensAddr, bytes32 node) { ens = ENS(ensAddr); rootNode = node; } function register(bytes32 subnode, address owner) { var node = sha3(rootNode, subnode); var currentOwner = ens.owner(node); if (currentOwner != 0 && currentOwner != msg.sender) throw; ens.setSubnodeOwner(rootNode, subnode, owner); } } You may wish to set custom rules for the allocation of new names to your users; the rules you set are entirely up to you. You should also bear in mind that as long as you retain ownership of the parent name - either directly or through another contract - your users have no guarantee that you will not take back ownership of their names and change what they resolve to. You may wish to consider committing ownership of the name to a contract that restricts your ability to control it. For an example of this, see ENSNow. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-migration-february-2020/guide-for-dapp-developers.html":{"url":"ens-migration-february-2020/guide-for-dapp-developers.html","title":"Guide for DApp Developers","keywords":"","body":"Guide for DApp Developers If you maintain a DApp, wallet, or library that depends on ENS, you will need to take action to ensure no disruption occurs for your users during and after the migration period. This document describes what you will need to do in order to update your app. What you need to do Wallets, libraries, and DApps that resolve names You should update the ENS registry address in your code to the new address of 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e as soon as possible. This new address is functional now, and will return the same results as the old one. Switching now ensures your users will not experience any disruption or interruption of service. If you do not update the registry address by the time the migration process begins on February 3rd, your users will begin to see out-of-date results: Names registered or updated after the migration will not resolve correctly for your users. If you maintain a library, you should release a new version with the updated address, and notify users that they should update as soon as possible. You may wish to consider publishing instructions for ‘monkeypatching’ the new address, in situations where users cannot easily upgrade to the latest version. All ENS deployments across mainnet and all testnets now use the same addresses. Wallets, libraries, and DApps that register or update names If your DApp or library allows users to register names, or to make changes to existing names, you have two options: Simply switch over to the new registry address as soon as possible. When you do, users will be temporarily unable to make changes to their names using your app until their name is migrated between the 3rd and 5th of February. When making a change to a name, call the `recordExists` function on the new registry. If it returns `true`, send the modification transaction to the new registry; otherwise, send it to the old one. If you take this option, you should still prohibit transfers of .ETH ERC721 tokens; a transfer that happens as the name is migrated could result in confusing results for users. The migration process will automatically transfer .ETH second-level domains (eg, foo.eth) to the new registry and registrar. Subdomains (eg, bar.foo.eth) and other top-level domains (eg, foo.xyz) will need to be migrated by their owners. For more details on this process, see our documentation, or reach out to us for help. ENS Secondary Marketplaces If you operate a marketplace that trades ENS names, you should immediately stop trading them. Although this vulnerability has not been exploited so far, once its existence is publicised we expect that attackers will reverse-engineer it and exploit it. Halting trading on the current registrar will prevent your users being affected by this. After a name has been migrated, tokens on the old registrar at 0xfac7bea255a6990f749363002136af6556b31e04 no longer correspond to ENS names, and are worthless; as a result you must disable trading of these before February 3rd 00:00UTC at the very latest. You can immediately enable trading of names on the new registrar, at address 0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85. When names are migrated to this contract starting on February 3rd 00:00 UTC, domain owners will automatically have new ERC721 tokens created on this new registrar, with the same ID as those on the current registrar. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "},"ens-migration-february-2020/technical-description.html":{"url":"ens-migration-february-2020/technical-description.html","title":"Technical Description","keywords":"","body":"Technical Description Recently, we were made aware of a vulnerability in the ENS registry contract. This vulnerability would make it possible for the owner of a domain to set a ‘back door’ such that they could transfer or sell the domain to another user, then, at a later time, claw back ownership of that domain without the new owner’s consent. The nature of this vulnerability is such that the attacker must at one point have had legitimate ownership of the domain in question, and they must set this ‘back door’ before they relinquished ownership of the name. As a result, this vulnerability cannot be exploited retrospectively. This vulnerability was reported via the Ethereum Foundation’s bug bounty process by Sam Sun. We have examined the ENS registry in detail, and are confident that nobody has previously exploited this vulnerability. As a result, ownership of all ENS names is secure. Due to this, ENS is migrating to a new deployment. This document describes the exact technical steps being taken, along with a brief description of their implications for DApp authors and users. This document is intended to provide a detailed description for anyone interested in the low-level details of the migration. Understanding this is not necessary for most users or developers; for a description of the vulnerability and its effect on users, see our medium post; for a description of the migration steps for developers see the guide for DApp developers. New ENS deployment A new instance of most ENS contracts is being deployed. Several of these have changes, while others are being redeployed in order to reference the new registry instead of the old one. ENS Registry A new version of the ENS registry has been deployed, and can be found at address 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e Besides fixing the vulnerability, we have taken the opportunity to implement a couple of additional features that will improve ENS’s usability going forward: Addition of `setRecord` and `setSubnodeRecord` methods, which allow setting owner, resolver, and TTL in a single operation. Addition of an approval mechanism based on ERC721, that allows users to delegate control over their names to another address, without having to transfer their names. The new registry implementation has been audited by Sam Sun, as well as reviewed by Consensys Diligence; no issues were found by either auditor. In order to make the migration as smooth as possible, the new registry has a fallback configured; if a record is not found in its own storage, it will look it up in the previous ENS registry contract. This fallback works only for read operations; if a record exists in the old registry but not yet in the new one, users cannot call functions to modify that record on the new registry. This means that to migrate each name over from the previous registry, the name must be recreated as if from scratch - so, for example, if ‘foo.eth’ does not yet exist in the new registry, the owner of ‘eth’ must create it in the same fashion as if it were a new domain, by calling `setSubnodeOwner` (or the new `setSubnodeRecord`). Other top-level domain owners (eg, .luxe, .kred, .club and .art) will need to do this on behalf of their users, so those users can recover write access to their domains. As a result of this fallback, if a record has not been migrated to the new registry, users and processes can continue to update records in the old registry; when they do, those changes will be reflected in the new one. At the point where a record is migrated to the new registry, it ceases to reflect any changes made in the old one. This ensures that names operated by smart contracts continue to function until their owners can take manual action to migrate them over. Migration strategies for each class of name are outlined below: Top-level domains (.eth, .luxe, .kred, .club, .art, .xyz, and .reverse) were migrated over as part of the deployment process. .eth second-level domains (eg, foo.eth) will be migrated over automatically for users - see the ‘migration contract’ section below for details. Subdomains managed by the Subdomain Registrar will also be migrated over automatically for users. Subdomains created by other means will need to be recreated by the owner of the parent domain calling `setSubnodeOwner` or `setSubnodeRecord`. The ENS dapp at app.ens.domains provides a one-click button to to do this for domains that are owned directly by users. Reverse records (.addr.reverse domains) will need to be recreated by repeating the ‘claim’ process in the ENS dapp UI. .xyz records will need to be migrated by repeating the ‘claim’ process proving ownership of the corresponding DNS domain. This can be done via the ENS Manager UI. .kred, .art, and .club domains will be migrated by the operators of those top-level domains. Name resolution will continue to work normally for names that have not yet been migrated to the new registry. Migration is only necessary in order for users to be able to change the name’s ownership, resolver, or TTL. .ETH Registrar A new instance of the .eth registrar (BaseRegistrarImplementation) has been deployed, and can be found at 0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85. This registrar is largely unchanged, with only a couple of minor modifications made to support the migration. Migration Contract A new contract, designed specifically for the migration process, has been deployed and can be found at 0x6109DD117AA5486605FC85e040ab00163a75c662. This contract is configured as a controller for the new .eth registrar, and will be set as the owner of .eth on the old registry once the migration process begins. Functions on this contract permit migrating .eth second-level names (eg, foo.eth) over from the old registry and registrar to the new ones. Once activated, the ENS team will submit transactions to migrate over all presently registered .eth second-level domains to the new deployment. Registrations for all names will be automatically moved over to the new registrar, with the same expiry date as they had previously. Registry records will be automatically migrated over, unless they are controlled by a contract. Records controlled by contracts will not be automatically migrated in order to avoid breaking registrar contracts. If you own a name that is controlled by a smart contract (for example, you’re using a custom registrar to allocate subdomains), you will need to deploy a new version of that contract that references the new ENS registry, then manually migrate the name yourself, by using the ‘Set controller’ functionality in the ENS manager dapp. In addition, the ENS team is automatically migrating over records from the legacy (auction-based) registrar. Names on the legacy registrar that have not previously been migrated over will be automatically created in the new deployment, with their expiration dates set to their existing expiry of May 4, 2020, meaning users will no longer have to do this manually - though they will still have to send a transaction to recover their deposit, which they can do at any time. This permits the new ENS deployment to do away with legacy code for supporting this obsolete registrar. Public Resolver A new instance of the public resolver has been deployed, and can be found at 0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41. This instance references the new ENS registry, and has an additional ‘multicall’ feature implemented, which permits users to set multiple records in a single operation. Since the public resolver looks up names in the ENS registry to determine who is permitted to configure records for them, while names - migrated or otherwise - pointed at an old instance of the public resolver will continue to function, they will need to migrate to the new public resolver in order to make changes. The ENS dapp at app.ens.domains facilitates this process using the new multicall function, making it possible to migrate over all records for a name in two transactions: the first one copying all records from the old resolver to the new one, and the second one updating the registry to point to the new resolver contract. .ETH Registrar Controller All registration requests for ENS .eth second-level names are processed via a ‘controller’ contract. Once the migration is complete and all names from the old registry and registrar have been re-registered on the new one, the ENS team will enable the standard registrar controller, which permits registrations via the standard two-transaction process. The controller contract has no changes from the previous deployment. Reverse Registrar A new instance of the reverse registrar has been deployed to point to the new registry. There are no changes to this compared to the old version. Reverse resolution will continue to function as normal throughout the transition. DNSSEC Registrar A new instance of the DNSSEC registrar has been deployed. The new instance retains all the functionality of the old one, while incorporating a few improvements that will make rolling DNSSEC support out to more top-level domains easier. Resolution of .xyz names will continue to function as normal, but any owners of these names wanting to make changes will have to repeat the ‘claim’ process to reclaim ownership of the name. Subdomain Registrar A new instance of the subdomain registrar has been deployed. This instance is largely unchanged from the previous version, except insofar as it supports migrating from that version to the new one. &a all right reserved，powered by GitbookUpdated at 2022-05-06 09:19:39 "}}